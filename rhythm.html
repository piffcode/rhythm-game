<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>RHYTHM - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        /* Defensive CSS to hide any stray media elements */
        audio, video, iframe, object, embed {
            display: none !important;
            visibility: hidden !important;
        }

        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .input-shield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            touch-action: none;
        }

        .shield-content {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            width: 90%;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin: 10px auto;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1db954;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            font-size: 16px;
            pointer-events: none;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .score {
            font-weight: bold;
            font-size: 18px;
        }

        .combo {
            font-size: 14px;
            opacity: 0.8;
        }

        .track-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .track-name {
            font-weight: bold;
            font-size: 16px;
        }

        .track-artist {
            font-size: 14px;
            opacity: 0.8;
        }

        .required-threshold {
            font-size: 12px;
            color: #1db954;
            margin-top: 5px;
        }

        .health-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 100%;
        }

        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 1001;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .results-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1db954, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 2000;
        }

        .results-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }

        .results-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px;
        }

        .track-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .track-result:last-child {
            border-bottom: none;
        }

        .track-result-name {
            font-weight: bold;
            font-size: 14px;
            flex: 1;
            text-align: left;
        }

        .track-result-score {
            font-size: 12px;
            text-align: right;
            margin-left: 10px;
        }

        .completion-code {
            background: rgba(29, 185, 84, 0.2);
            border: 1px solid rgba(29, 185, 84, 0.5);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 2rem;
            text-align: center;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }

        .back-link {
            color: #1db954;
            text-decoration: none;
            font-size: 16px;
            margin-top: 1rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff4444, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 3000;
            text-align: center;
        }

        .error-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .error-message {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            max-width: 400px;
        }

        .timing-debug {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 4px;
            z-index: 200;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Game Canvas -->
    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Game HUD -->
        <div class="hud">
            <div class="hud-top">
                <div class="score" id="scoreDisplay">0</div>
                <div class="combo" id="comboDisplay">0x</div>
            </div>
            <div class="track-info">
                <div class="track-name" id="trackName">Loading...</div>
                <div class="track-artist" id="trackArtist"></div>
                <div class="required-threshold" id="requiredThreshold"></div>
            </div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill"></div>
            </div>
        </div>

        <!-- Timing Debug (hidden by default) -->
        <div class="timing-debug" id="timingDebug">
            <div id="timingInfo">Timing Info</div>
        </div>

        <!-- Input Shield (shown during loading) -->
        <div class="input-shield" id="inputShield">
            <div class="shield-content">
                <div class="spinner"></div>
                <div style="margin-top: 20px;" id="shieldMessage">Initializing game...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Screen -->
    <div class="results-screen" id="resultsScreen">
        <div class="results-title">Session Complete</div>
        <div class="results-stats" id="resultsStats">
            <!-- Track results will be populated here -->
        </div>
        <div class="completion-code">
            <div style="margin-bottom: 8px; font-weight: bold;">Completion Code:</div>
            <div id="completionCode">RHYTHM-20241217-A1B2C3D4</div>
        </div>
        <a href="/" class="back-link">Play Again</a>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <div class="error-title">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong</div>
        <a href="/" class="back-link">Back to Start</a>
    </div>

    <script type="module">
        import { config, generateCompletionCode } from './config.js';
        import { PKCE } from './auth-pkce.js';
        import { SpotifyClient } from './spotify-client.js';
        import { NativeSpotifyPlayback } from './native-spotify-playback.js';
        import { GameEngine } from './game-engine.js';
        import { GameInput } from './game-input.js';
        import { GameRender } from './game-render.js';
        import { GameUI } from './game-ui.js';
        import { MidiChartGenerator } from './midi-chart-generator.js';

        // Global app state
        let app = {
            auth: null,
            client: null,
            playback: null,
            engine: null,
            input: null,
            render: null,
            ui: null,
            isInitialized: false,
            gameLoopId: null,
            timingClock: null // High precision timing
        };

        // ADD ALL OF THIS HERE:
        // Natural listening behavior state
        let naturalListening = {
            skipThreshold: 0,
            shouldShowSavePrompt: false,
            savePromptShown: false,
            savePromptDelay: 0,
            currentTrackIndex: 0,
            trackStartTime: 0
        };

        // Initialize natural listening for a track
        function initializeNaturalListening(trackIndex, trackDuration) {
            // Calculate random skip point between 88-100% of the song
            const minPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MIN;
            const maxPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MAX;
            const skipPercent = minPercent + Math.random() * (maxPercent - minPercent);
            
            naturalListening.skipThreshold = (skipPercent / 100) * trackDuration;
            naturalListening.currentTrackIndex = trackIndex;
            naturalListening.trackStartTime = Date.now();
            naturalListening.savePromptShown = false;
            
            // Determine if we should show save prompt for track 2
            if (trackIndex === config.NATURAL_LISTENING.SAVE_PROMPT_TRACK - 1) { // Track 2 (0-indexed = 1)
                naturalListening.shouldShowSavePrompt = Math.random() < config.NATURAL_LISTENING.SAVE_PROMPT_PROBABILITY;
                if (naturalListening.shouldShowSavePrompt) {
                    // Random delay between 1-5 seconds after track ends
                    const minDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MIN;
                    const maxDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MAX;
                    naturalListening.savePromptDelay = minDelay + Math.random() * (maxDelay - minDelay);
                    console.log(`Save prompt will show after ${naturalListening.savePromptDelay}ms delay`);
                }
            } else {
                naturalListening.shouldShowSavePrompt = false;
            }
            
            console.log(`Natural listening: Skip at ${skipPercent.toFixed(1)}% (${naturalListening.skipThreshold}ms)`);
        }

        // Check if we should skip to next track
        function checkNaturalSkip(currentPosition) {
            if (currentPosition >= naturalListening.skipThreshold) {
                console.log('Natural skip triggered - advancing to next track');
                if (app.playback && app.playback.advanceTrack) {
                    app.playback.advanceTrack();
                }
                return true;
            }
            return false;
        }

        // Show save prompt after track ends
        function showSavePrompt(track) {
            if (!naturalListening.shouldShowSavePrompt || naturalListening.savePromptShown) {
                return;
            }
            
            naturalListening.savePromptShown = true;
            
            setTimeout(async () => {
                try {
                    // Create a natural-looking save prompt
                    const savePrompt = document.createElement('div');
                    savePrompt.style.cssText = `
                        position: fixed;
                        bottom: 120px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(30, 30, 30, 0.95);
                        backdrop-filter: blur(10px);
                        color: white;
                        padding: 16px 20px;
                        border-radius: 25px;
                        font-size: 14px;
                        z-index: 1001;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        border: 1px solid rgba(255,255,255,0.1);
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        max-width: 90%;
                        animation: slideUpFade 0.3s ease-out;
                    `;
                    
                    // Add slide up animation
                    if (!document.querySelector('#savePromptStyle')) {
                        const style = document.createElement('style');
                        style.id = 'savePromptStyle';
                        style.textContent = `
                            @keyframes slideUpFade {
                                0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                                100% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // Heart icon
                    const heartIcon = document.createElement('div');
                    heartIcon.innerHTML = 'ü§ç';
                    heartIcon.style.fontSize = '18px';
                    
                    // Track info
                    const trackInfo = document.createElement('div');
                    trackInfo.innerHTML = `
                        <div style="font-weight: 500; margin-bottom: 2px;">${track.name}</div>
                        <div style="font-size: 12px; opacity: 0.7;">${track.artists?.[0]?.name || 'Unknown Artist'}</div>
                    `;
                    
                    // Save button
                    const saveButton = document.createElement('button');
                    saveButton.textContent = 'Save';
                    saveButton.style.cssText = `
                        background: #1db954;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    `;
                    
                    // Close button
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '√ó';
                    closeButton.style.cssText = `
                        background: none;
                        color: rgba(255,255,255,0.7);
                        border: none;
                        font-size: 18px;
                        cursor: pointer;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: 8px;
                    `;
                    
                    savePrompt.appendChild(heartIcon);
                    savePrompt.appendChild(trackInfo);
                    savePrompt.appendChild(saveButton);
                    savePrompt.appendChild(closeButton);
                    
                    document.body.appendChild(savePrompt);
                    
                    // Button interactions
                    saveButton.addEventListener('mouseenter', () => {
                        saveButton.style.background = '#1ed760';
                        saveButton.style.transform = 'scale(1.05)';
                    });
                    
                    saveButton.addEventListener('mouseleave', () => {
                        saveButton.style.background = '#1db954';
                        saveButton.style.transform = 'scale(1)';
                    });
                    
                    // Save functionality
                    saveButton.addEventListener('click', async () => {
                        try {
                            await app.client.saveTrack(track.id);
                            
                            // Update button to show success
                            heartIcon.innerHTML = 'üíö';
                            saveButton.textContent = 'Saved!';
                            saveButton.style.background = '#1ed760';
                            saveButton.disabled = true;
                            
                            console.log(`Track saved: ${track.name}`);
                            
                            // Remove after showing success
                            setTimeout(() => {
                                if (savePrompt.parentNode) {
                                    savePrompt.style.animation = 'slideDownFade 0.3s ease-out';
                                    setTimeout(() => {
                                        if (savePrompt.parentNode) {
                                            savePrompt.parentNode.removeChild(savePrompt);
                                        }
                                    }, 300);
                                }
                            }, 2000);
                            
                        } catch (error) {
                            console.error('Failed to save track:', error);
                            saveButton.textContent = 'Error';
                            saveButton.style.background = '#ff4444';
                        }
                    });
                    
                    // Close functionality
                    const closeSavePrompt = () => {
                        if (savePrompt.parentNode) {
                            savePrompt.style.animation = 'slideDownFade 0.3s ease-out';
                            setTimeout(() => {
                                if (savePrompt.parentNode) {
                                    savePrompt.parentNode.removeChild(savePrompt);
                                }
                            }, 300);
                        }
                    };
                    
                    closeButton.addEventListener('click', closeSavePrompt);
                    
                    // Auto-close after 8 seconds
                    setTimeout(closeSavePrompt, 8000);
                    
                    // Add slide down animation
                    if (!document.querySelector('#slideDownStyle')) {
                        const slideStyle = document.createElement('style');
                        slideStyle.id = 'slideDownStyle';
                        slideStyle.textContent = `
                            @keyframes slideDownFade {
                                0% { opacity: 1; transform: translateX(-50%) translateY(0); }
                                100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                            }
                        `;
                        document.head.appendChild(slideStyle);
                    }
                    
                } catch (error) {
                    console.error('Failed to show save prompt:', error);
                }
            }, naturalListening.savePromptDelay);
        }

        // High precision timing clock
        class TimingClock {
            constructor() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
                this.performanceOffset = 0; // Calibration for audio latency
            }

            start() {
                this.startTime = performance.now();
                this.pausedTime = 0;
                this.isPaused = false;
            }

            pause() {
                if (!this.isPaused && this.startTime) {
                    this.isPaused = true;
                    this.pausedTime = performance.now();
                }
            }

            resume() {
                if (this.isPaused && this.pausedTime > 0) {
                    const pauseDuration = performance.now() - this.pausedTime;
                    this.startTime += pauseDuration;
                    this.isPaused = false;
                    this.pausedTime = 0;
                }
            }

            getTime() {
                if (!this.startTime) return 0;
                if (this.isPaused) {
                    return this.pausedTime - this.startTime + this.performanceOffset;
                }
                return performance.now() - this.startTime + this.performanceOffset;
            }

            setCalibration(offsetMs) {
                this.performanceOffset = offsetMs;
            }

            reset() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
            }
        }

        // Progress tracking
        let initProgress = 0;
        const initSteps = 7; // Reduced steps for native playback

        // Update progress display
        function updateProgress(step, message) {
            initProgress = step;
            const percentage = Math.round((step / initSteps) * 100);
            updateShieldMessage(message);
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
        }

        // Auto-calibration function
        async function autoCalibrate() {
            try {
                // Get tempo information from the current track or MIDI data
                let targetOffset = 0;
                if (app.engine && app.engine.currentChart && app.engine.currentChart.metadata.source === 'midi') {
                    // For MIDI tracks, use a small positive offset to account for processing
                    targetOffset = 15; // 15ms ahead to compensate for processing delay
                } else {
                    // For other tracks, use audio analysis or default
                    const track = await app.client.getCurrentPlaybackState();
                    if (track && track.item) {
                        try {
                            const features = await app.client.getAudioFeatures(track.item.id);
                            const tempo = features.tempo || 120;
                            
                            // Calculate offset based on tempo (slower songs need more lookahead)
                            if (tempo < 90) {
                                targetOffset = 25; // Slower songs
                            } else if (tempo > 140) {
                                targetOffset = 10; // Faster songs
                            } else {
                                targetOffset = 15; // Medium tempo
                            }
                        } catch (error) {
                            console.warn('Could not get audio features, using default offset');
                            targetOffset = 15;
                        }
                    }
                }

                // Apply the calculated offset
                if (app.playback) {
                    app.playback.setCalibrationOffset(targetOffset);
                    console.log(`Auto-calibration set to ${targetOffset}ms`);
                }
            } catch (error) {
                console.warn('Auto-calibration failed:', error);
                // Use default offset
                if (app.playback) {
                    app.playback.setCalibrationOffset(15);
                }
            }
        }

        // Initialize the game
        async function initGame() {
            try {
                updateProgress(0, 'Validating session...');

                // Validate bootstrap nonce
                const urlParams = new URLSearchParams(window.location.search);
                const bootstrap = urlParams.get('bootstrap');
                const storedNonce = sessionStorage.getItem('bootstrap_nonce');

                if (!bootstrap || bootstrap !== storedNonce) {
                    throw new Error('Invalid session. Please start over.');
                }
                sessionStorage.removeItem('bootstrap_nonce');

                updateProgress(1, 'Connecting to Spotify...');

                // Initialize Spotify client
                app.client = new SpotifyClient();
                await app.client.initialize();

                updateProgress(2, 'Checking Premium and finding devices...');
                await checkPremiumStatus();

                updateProgress(3, 'Connecting to native Spotify app...');

                // Use native Spotify playback instead of Web Playback SDK
                app.playback = new NativeSpotifyPlayback(app.client);
                try {
                    await app.playback.initialize();
                } catch (error) {
                    if (error.message && error.message.includes('device')) {
                        throw new Error('Unable to connect to Spotify. Please make sure Spotify is open and playing on your device, then refresh this page.');
                    }
                    throw error;
                }

                updateProgress(4, 'Initializing game components...');

                // Initialize timing clock
                app.timingClock = new TimingClock();

                // Initialize game components in parallel
                const canvas = document.getElementById('gameCanvas');
                await Promise.all([
                    new Promise(resolve => {
                        app.engine = new GameEngine();
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.input = new GameInput(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.render = new GameRender(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.ui = new GameUI();
                        resolve();
                    })
                ]);
                
                // Wait for MIDI files to load
                console.log('Waiting for MIDI files to load...');
                await new Promise(resolve => {
                    const checkMidi = () => {
                        const availableTracks = app.engine.midiGenerator.getAvailableTracks();
                        if (availableTracks.length > 0) {
                            console.log(`MIDI loaded for ${availableTracks.length} tracks:`, availableTracks);
                            resolve();
                        } else {
                            console.log('Still waiting for MIDI files...');
                            setTimeout(checkMidi, 500);
                        }
                    };
                    checkMidi();
                });

                // Override config for higher note density
                if (window.config && window.config.CHART) {
                    window.config.CHART.DENSITY_MULTIPLIERS = {
                        EASY: 1.0,
                        NORMAL: 1.5,   // Increased from default
                        HARD: 2.0      // Increased from default
                    };
                    window.config.CHART.MIN_NOTE_SPACING = 100; // Reduced from default to allow closer notes
                    console.log('Note density increased for more challenging gameplay');
                }

                updateProgress(5, 'Setting up event handlers...');
                setupEventHandlers();

                updateProgress(6, 'Preparing game session...');
                await startGameSession();

                updateProgress(7, 'Ready!');

                // Auto-calibrate based on tempo instead of showing manual calibration
                await autoCalibrate();

                // Enable debug mode toggle (press D key)
                setupDebugMode();

                // Small delay to show completion
                await new Promise(resolve => setTimeout(resolve, 500));

                // Hide input shield and start game
                document.getElementById('inputShield').style.display = 'none';
                app.isInitialized = true;
                startGameLoop();

            } catch (error) {
                console.error('Game initialization failed:', error);
                showError(error.message || 'Failed to initialize game');
            }
        }

        function setupEventHandlers() {
            // Input to engine connection
            app.input.onLaneHit = (lane, time) => {
                const gameTime = app.timingClock.getTime();
                const result = app.engine.handleLaneHit(lane, gameTime);
                if (result) {
                    app.render.addHitEffect(lane, result.hitType, result.score);
                    if (result.combo > 10) {
                        app.render.addComboPopup(result.combo, result.score);
                    }
                }
            };

            // Engine event handlers
            app.engine.onTrackStart = (track, requiredPercent) => {
                console.log(`Track started: ${track.name} (${requiredPercent}% required)`);
                app.timingClock.start(); // Start precise timing when track starts
            };

            app.engine.onTrackEnd = (result) => {
    app.ui.showTrackComplete(result);
    app.timingClock.pause();
    
    // ADD THESE LINES:
    if (naturalListening.currentTrackIndex === config.NATURAL_LISTENING.SAVE_PROMPT_TRACK - 1 && 
        naturalListening.shouldShowSavePrompt && 
        result.currentTrack) {
        showSavePrompt(result.currentTrack);
    }
};
            app.engine.onSessionComplete = (result) => {
                app.ui.showResults(result);
                stopGameLoop();
                app.timingClock.reset();
                // Auto-calibration is handled per track, no manual panel needed
            };

            // Add the track completion callback handlers
            app.engine.onAdvanceTrack = (trackIndex) => {
                console.log(`Game engine requesting advance to track ${trackIndex}`);
                // Only advance if we have more tracks to play
                if (trackIndex < app.engine.tracks.length) {
                    if (app.playback && app.playback.advanceTrack) {
                        app.playback.advanceTrack();
                    } else {
                        console.error('Playback system does not support advanceTrack method');
                    }
                } else {
                    console.log('No more tracks to advance to - session should be complete');
                }
            };

            // Native playback event handlers
app.playback.onTrackChange = async (track) => {
                try {
                    console.log(`Track changed: ${track.name}`);
                    
                    // Check if MIDI data exists for this track - MANDATORY
                    if (!app.engine.midiGenerator.hasMidiData(track.id)) {
                        const error = `No MIDI data available for track: ${track.name} (${track.id}). Game requires MIDI charts to function.`;
                        console.error(error);
                        showError(error);
                        return;
                    }

                    // Initialize natural listening behavior for this track
                    const trackDuration = track.duration_ms || 180000;
                    const currentTrackIndex = app.engine.currentTrackIndex || 0;
                    initializeNaturalListening(currentTrackIndex, trackDuration);

                    // Auto-calibrate for this track
                    await autoCalibrate();

                    // Reset and start timing clock for new track
                    app.timingClock.reset();
                    app.timingClock.start();

                    // ONLY try MIDI - no fallbacks allowed
                    try {
                        await app.engine.startTrack(track, null);
                        console.log('Track started successfully with MIDI chart');
                    } catch (error) {
                        const errorMsg = `Failed to start MIDI track: ${track.name}. ${error.message}`;
                        console.error(errorMsg);
                        showError(errorMsg);
                        return;
                    }

                } catch (error) {
                    const errorMsg = `Critical error loading track: ${track.name}. ${error.message}`;
                    console.error(errorMsg);
                    showError(errorMsg);
                }
            };

            app.playback.onStateChange = (state) => {
                // Sync timing clock with playback state
                if (state.is_playing && app.timingClock.isPaused) {
                    app.timingClock.resume();
                } else if (!state.is_playing && !app.timingClock.isPaused) {
                    app.timingClock.pause();
                }
            };

            // Enable input after initialization
            app.input.enable();
        }

        function setupDebugMode() {
            let debugMode = false;
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'd') {
                    debugMode = !debugMode;
                    const debugPanel = document.getElementById('timingDebug');
                    debugPanel.style.display = debugMode ? 'block' : 'none';
                }
            });

            // Update debug info
            setInterval(() => {
                if (debugMode && app.playback && app.timingClock) {
                    const spotifyPos = app.playback.getPositionMs();
                    const clockTime = app.timingClock.getTime();
                    const drift = Math.abs(spotifyPos - clockTime);
                    const autoOffset = app.playback.calibrationOffset || 0;

                    document.getElementById('timingInfo').innerHTML = `
                        Spotify: ${spotifyPos.toFixed(0)}ms<br>
                        Clock: ${clockTime.toFixed(0)}ms<br>
                        Drift: ${drift.toFixed(0)}ms<br>
                        Auto-Offset: ${autoOffset}ms<br>
                        Playing: ${app.playback.getIsPlaying() ? 'Yes' : 'No'}
                    `;
                }
            }, 100);
        }

        async function checkPremiumStatus() {
            try {
                const devices = await app.client.request('/v1/me/player/devices');
                
                // Check if any active devices are available
                if (!devices.devices || devices.devices.length === 0) {
                    throw new Error('No Spotify devices found. Please open Spotify on your phone, computer, or other device and make sure you\'re logged in, then refresh this page.');
                }
                
                // Check if any device is currently active
                const hasActiveDevice = devices.devices.some(device => device.is_active);
                if (!hasActiveDevice) {
                    // Try to find a device that can be activated
                    const availableDevice = devices.devices.find(device => !device.is_restricted);
                    if (!availableDevice) {
                        throw new Error('No available Spotify devices found. Please start playing music on Spotify (on any device) to activate a device, then refresh this page.');
                    }
                }
                
            } catch (error) {
                if (error.status === 403) {
                    throw new Error(config.ERRORS.NO_PREMIUM);
                } else if (error.message.includes('Spotify devices') || error.message.includes('available Spotify devices')) {
                    // Re-throw our custom device messages
                    throw error;
                } else {
                    // Generic device check error
                    throw new Error('Unable to connect to Spotify devices. Please make sure Spotify is open and you\'re logged in, then refresh this page.');
                }
            }
        }

        async function startGameSession() {
            try {
                // Get user profile
                const profile = await app.client.request('/v1/me');
                const country = new URLSearchParams(window.location.search).get('country') || 
                               sessionStorage.getItem('country') || 
                               profile.country || 'US';

                // Generate track list
                const tracks = await generateTrackList(country);
                
                // CRITICAL: Validate that ALL tracks have MIDI data
                const tracksWithMidi = tracks.filter(trackId => app.engine.midiGenerator.hasMidiData(trackId));
                const tracksWithoutMidi = tracks.filter(trackId => !app.engine.midiGenerator.hasMidiData(trackId));
                
                console.log(`Tracks with MIDI: ${tracksWithMidi.length}/${tracks.length}`);
                console.log('Available MIDI tracks:', tracksWithMidi);
                
                if (tracksWithoutMidi.length > 0) {
                    console.warn('Tracks missing MIDI:', tracksWithoutMidi);
                }
                
                if (tracksWithMidi.length === 0) {
                    throw new Error('No tracks with MIDI data available. Game requires MIDI charts to function.');
                }
                
                // Use only tracks that have MIDI data
                const finalTracks = tracksWithMidi;
                console.log(`Using ${finalTracks.length} tracks with MIDI data`);

                // Create playlists in parallel
                const playlistNames = generatePlaylistNames(country);
                const [publicPlaylist, privatePlaylist] = await Promise.all([
                    createPlaylist(profile.id, playlistNames.public, true).catch(() => null),
                    createPlaylist(profile.id, playlistNames.private, false).catch(() => null)
                ]);

                // Add tracks to playlists (non-blocking)
                const trackUris = finalTracks.map(id => `spotify:track:${id}`);
                if (publicPlaylist) {
                    addTracksToPlaylist(publicPlaylist.id, trackUris).catch(console.warn);
                }
                if (privatePlaylist) {
                    addTracksToPlaylist(privatePlaylist.id, trackUris).catch(console.warn);
                }

                // Initialize game session with MIDI-validated tracks
                app.engine.initializeSession(finalTracks, profile.id, generateUUID());

                // Start playlist on user's native Spotify app
                const playlistToUse = publicPlaylist || privatePlaylist;
                if (playlistToUse) {
                    updateShieldMessage('Starting playlist on your Spotify app...');
                    await app.playback.startPlayback(playlistToUse.uri, 0);
                    app.playback.lockControls(playlistToUse.uri, finalTracks);
                } else {
                    throw new Error('Failed to create any playlists');
                }

            } catch (error) {
                console.error('Failed to start game session:', error);
                throw new Error('Failed to start game session: ' + error.message);
            }
        }

        function startGameLoop() {
            let lastTime = performance.now();

            function gameLoop(currentTime) {
                if (!app.isInitialized) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                // Get current position from Spotify playback
                let spotifyPosition = 0;
                if (app.playback && app.playback.getIsPlaying()) {
                    spotifyPosition = app.playback.getPositionMs();  
                    // ADD THIS LINE:
                checkNaturalSkip(spotifyPosition);
                    
                }

                // Use our high-precision timing clock, but sync with Spotify periodically
                let gameTime = app.timingClock.getTime();
                
                // Sync with Spotify position every 2 seconds if there's significant drift
                if (spotifyPosition > 0) {
                    const drift = Math.abs(gameTime - spotifyPosition);
                    if (drift > 200) { // More than 200ms drift
                        console.log(`Syncing game time: ${gameTime}ms -> ${spotifyPosition}ms (drift: ${drift}ms)`);
                        app.timingClock.reset();
                        app.timingClock.start();
                        // Adjust the start time to match Spotify
                        app.timingClock.startTime = performance.now() - spotifyPosition;
                        gameTime = spotifyPosition;
                    }
                }

                // Update game components
                app.engine.update(deltaTime, gameTime);
                app.input.update();
                app.ui.update(app.engine.getGameState());

                // Render frame
                app.render.render(app.engine.getGameState());

                // Continue loop
                app.gameLoopId = requestAnimationFrame(gameLoop);
            }

            app.gameLoopId = requestAnimationFrame(gameLoop);
        }

        function stopGameLoop() {
            if (app.gameLoopId) {
                cancelAnimationFrame(app.gameLoopId);
                app.gameLoopId = null;
            }
        }

        async function generateTrackList(country) {
            const lockedTracks = config.LOCKED_TRACK_IDS;
            
            try {
                const fallback = await app.client.getRecommendations({
                    seed_genres: 'pop,dance',
                    market: country,
                    limit: 1
                });

                if (fallback.tracks && fallback.tracks.length > 0) {
                    return [...lockedTracks, fallback.tracks[0].id];
                }
            } catch (error) {
                console.warn('Recommendations failed:', error);
            }

            return [...lockedTracks, lockedTracks[0]];
        }

function generatePlaylistNames(country) {
            const names = [
                unction generatePlaylistNames(country) {
            const names = [
                'my mix', 'current rotation', 'on repeat', 'lately', 'vibes',
                'summer nights', 'drive music', 'good stuff', 'favorites', 'new finds',
                'mood', 'chill mix', 'bangers', 'late night', 'feel good',
                'weekend', 'daily driver', 'fresh', 'liked songs pt. 2', 'study vibes',
                'workout', 'road trip', 'throwbacks', 'hits different', 'no skips',
                'that playlist', 'main character energy', 'gym', 'car songs', 'rain day',
                'golden hour', 'untitled', '‚ú® vibes ‚ú®', 'idc what anyone says', 'songs i fw',
                'this month', 'lowkey fire', 'comfort songs', 'winter feels',
                'midnight thoughts', 'shower songs', 'cooking playlist', 'gaming music',
                'work from home', 'sunset drives', 'running mix', 'party mode',
                'sleepy time', 'morning coffee', 'house cleaning', 'focus mode',
                'rainy days', 'spring cleaning', 'roadtrip 2024', 'guilty pleasures',
                'throwback thursday', 'sunday morning', 'study session', 'pre-game',
                'after hours', 'background music', 'nostalgic feels', 'energy boost',
                'chill sunday', 'late night drives', 'good energy only', 'motivation',
                'car karaoke', 'walk the dog', 'cleaning house', 'cooking dinner',
                'getting ready', 'wind down', 'productivity', 'happy songs',
                'sad girl hours', 'confidence boost', 'beach day', 'autumn vibes',
                'cozy evening', 'dance party', 'sing along', 'discover weekly pt 2'
            ];
            
            const selectedName = names[Math.floor(Math.random() * names.length)];
            
            return {
                public: selectedName,
                private: selectedName
            };
        }

        async function createPlaylist(userId, name, isPublic) {
            return await app.client.createPlaylist(userId, {
                name: name,
                public: isPublic
                // No description - will be blank
            });
        }

        async function addTracksToPlaylist(playlistId, uris) {
            await app.client.addTracksToPlaylist(playlistId, uris);
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function updateShieldMessage(message) {
            const element = document.getElementById('shieldMessage');
            if (element) {
                element.textContent = message;
            }
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorScreen').style.display = 'flex';
        }

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && app.isInitialized && app.timingClock) {
                app.timingClock.pause();
            } else if (!document.hidden && app.isInitialized && app.timingClock && app.playback?.getIsPlaying()) {
                app.timingClock.resume();
            }
        });

        // Handle beforeunload
        window.addEventListener('beforeunload', () => {
            if (app.playback) {
                app.playback.unlockControls();
            }
            if (app.timingClock) {
                app.timingClock.reset();
            }
            stopGameLoop();
        });

        // Initialize the game when page loads
        initGame();
    </script>
</body>
</html>
