<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>RHYTHM - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        /* Defensive CSS to hide any stray media elements */
        audio, video, iframe, object, embed {
            display: none !important;
            visibility: hidden !important;
        }

        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .input-shield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            touch-action: none;
        }

        .shield-content {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            width: 90%;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin: 10px auto;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1db954;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        /* Additional CSS for the new loading screen */
        .loading-step {
            width: 100%;
            max-width: 450px;
        }

        .step-content {
            text-align: center;
        }

        .step-content.hidden {
            display: none;
        }

        .step-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.9;
        }

        .step-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #1db954;
        }

        .step-description {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            opacity: 0.9;
            line-height: 1.4;
        }

        .step-instructions {
            text-align: left;
            max-width: 350px;
            margin: 0 auto 1.5rem;
            padding-left: 1rem;
        }

        .step-instructions li {
            margin-bottom: 0.8rem;
            font-size: 0.95rem;
            line-height: 1.4;
            opacity: 0.9;
        }

        .step-note {
            font-size: 0.85rem;
            opacity: 0.7;
            margin-bottom: 2rem;
            font-style: italic;
            color: #cccccc;
        }

        .continue-btn {
            background: #1db954;
            color: white;
            border: none;
            padding: 16px 32px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(29, 185, 84, 0.3);
            margin-bottom: 1rem;
        }

        .continue-btn:hover {
            background: #1ed760;
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(29, 185, 84, 0.4);
        }

        .continue-btn:active {
            transform: translateY(0);
        }

        .step-message {
            font-size: 1.1rem;
            margin: 1rem 0;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .step-icon {
                font-size: 3rem;
            }
            
            .step-title {
                font-size: 1.5rem;
            }
            
            .step-instructions {
                padding-left: 0.5rem;
                max-width: 300px;
            }
            
            .step-instructions li {
                font-size: 0.9rem;
            }
            
            .continue-btn {
                padding: 14px 28px;
                font-size: 1rem;
            }
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            font-size: 16px;
            pointer-events: none;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .score {
            font-weight: bold;
            font-size: 18px;
        }

        .combo {
            font-size: 14px;
            opacity: 0.8;
        }

        .track-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .track-name {
            font-weight: bold;
            font-size: 16px;
        }

        .track-artist {
            font-size: 14px;
            opacity: 0.8;
        }

        .required-threshold {
            font-size: 12px;
            color: #1db954;
            margin-top: 5px;
        }

        .health-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 100%;
        }

        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 1001;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .results-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1db954, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 2000;
        }

        .results-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }

        .results-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px;
        }

        .track-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .track-result:last-child {
            border-bottom: none;
        }

        .track-result-name {
            font-weight: bold;
            font-size: 14px;
            flex: 1;
            text-align: left;
        }

        .track-result-score {
            font-size: 12px;
            text-align: right;
            margin-left: 10px;
        }

        .completion-code {
            background: rgba(29, 185, 84, 0.2);
            border: 1px solid rgba(29, 185, 84, 0.5);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 2rem;
            text-align: center;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }

        .back-link {
            color: #1db954;
            text-decoration: none;
            font-size: 16px;
            margin-top: 1rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff4444, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 3000;
            text-align: center;
        }

        .error-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .error-message {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            max-width: 400px;
        }

        .timing-debug {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 12px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 6px;
            z-index: 200;
            display: none;
            width: 280px;
            max-height: 60vh;
            overflow: hidden;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
        }

        .timing-debug .debug-section {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        .timing-debug .debug-section:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        .debug-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.75;
            margin-bottom: 4px;
        }

        .debug-events {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .debug-event {
            display: flex;
            gap: 6px;
            font-size: 11px;
            line-height: 1.4;
        }

        .debug-event-time {
            color: rgba(255, 255, 255, 0.55);
            flex-shrink: 0;
        }

        .debug-event-name {
            color: #1db954;
            flex-shrink: 0;
        }

        .debug-event-payload {
            color: rgba(255, 255, 255, 0.85);
            flex: 1;
            word-break: break-word;
        }
    </style>
</head>
<body>
    <!-- Game Canvas -->
    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Game HUD -->
        <div class="hud">
            <div class="hud-top">
                <div class="score" id="scoreDisplay">0</div>
                <div class="combo" id="comboDisplay">0x</div>
            </div>
            <div class="track-info">
                <div class="track-name" id="trackName">Loading...</div>
                <div class="track-artist" id="trackArtist"></div>
                <div class="required-threshold" id="requiredThreshold"></div>
            </div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill"></div>
            </div>
        </div>

        <!-- Timing Debug (hidden by default) -->
        <div class="timing-debug" id="timingDebug">
            <div class="debug-section">
                <div class="debug-section-title">Metrics</div>
                <div id="timingInfo">Timing Info</div>
            </div>
            <div class="debug-section">
                <div class="debug-section-title">Recent Events</div>
                <div class="debug-events" id="debugEvents"></div>
            </div>
        </div>

        <!-- Enhanced Input Shield with New Loading Screen -->
        <div class="input-shield" id="inputShield">
            <div class="shield-content">
                <div class="loading-step" id="loadingStep">
                    <!-- Step 1: Spotify Setup -->
                    <div class="step-content" id="spotifySetup">
                        <div class="step-icon">🎵</div>
                        <h2 class="step-title">Open Spotify First</h2>
                        <p class="step-description">
                            Before we start the game, please:
                        </p>
                        <ol class="step-instructions">
                            <li>Open your Spotify app (phone, computer, or web)</li>
                            <li>Start playing any song to activate your device</li>
                            <li>Come back here and click Continue</li>
                        </ol>
                        <div class="step-note">
                            This ensures the game can connect to your active Spotify device
                        </div>
                        <button class="continue-btn" id="continueBtn" onclick="continueToGame()">
                            Continue to Game
                        </button>
                    </div>
                    
                    <!-- Step 2: Loading Game -->
                    <div class="step-content hidden" id="gameLoading">
                        <div class="spinner"></div>
                        <div class="step-message" id="shieldMessage">Initializing game...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="step-note" id="loadingNote">
                            Setting up your rhythm game experience...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Screen -->
    <div class="results-screen" id="resultsScreen">
        <div class="results-title">Session Complete</div>
        <div class="results-stats" id="resultsStats">
            <!-- Track results will be populated here -->
        </div>
        <div class="completion-code">
            <div style="margin-bottom: 8px; font-weight: bold;">Completion Code:</div>
            <div id="completionCode">RHYTHM-20241217-A1B2C3D4</div>
        </div>
        <a href="/" class="back-link">Play Again</a>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <div class="error-title">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong</div>
        <a href="/" class="back-link">Back to Start</a>
    </div>

    <script type="module">
        import { config, generateCompletionCode } from './config.js';
        import { SpotifyClient } from './spotify-client.js';
        import { NativeSpotifyPlayback } from './native-spotify-playback.js';
        import { GameEngine } from './game-engine.js';
        import { GameInput } from './game-input.js';
        import { GameRender } from './game-render.js';
        import { GameUI } from './game-ui.js';
        import { GameDebugger } from './game-debug.js';

        // Global app state
        let app = {
            auth: null,
            client: null,
            playback: null,
            engine: null,
            input: null,
            render: null,
            ui: null,
            isInitialized: false,
            gameLoopId: null,
            timingClock: null, // High precision timing
            debugger: null
        };

        app.debugger = new GameDebugger({
            maxEvents: 120,
            pollInterval: 200,
            consoleMirror: false
        });
        app.debugger.setExtraMetrics({ 'Session Status': 'Starting' });

        // Natural listening behavior state
        let naturalListening = {
            skipThreshold: 0,
            shouldShowSavePrompt: false,
            savePromptShown: false,
            savePromptDelay: 0,
            currentTrackIndex: 0,
            trackStartTime: 0
        };

        // Initialize natural listening for a track
        function initializeNaturalListening(trackIndex, trackDuration) {
            // Calculate random skip point between 88-100% of the song
            const minPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MIN;
            const maxPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MAX;
            const skipPercent = minPercent + Math.random() * (maxPercent - minPercent);

            naturalListening.skipThreshold = (skipPercent / 100) * trackDuration;
            naturalListening.currentTrackIndex = trackIndex;
            naturalListening.trackStartTime = Date.now();
            naturalListening.savePromptShown = false;

            // Determine if we should show save prompt for track 2
            if (trackIndex === config.NATURAL_LISTENING.SAVE_PROMPT_TRACK - 1) { // Track 2 (0-indexed = 1)
                naturalListening.shouldShowSavePrompt = Math.random() < config.NATURAL_LISTENING.SAVE_PROMPT_PROBABILITY;
                if (naturalListening.shouldShowSavePrompt) {
                    // Random delay between 1-5 seconds after track ends
                    const minDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MIN;
                    const maxDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MAX;
                    naturalListening.savePromptDelay = minDelay + Math.random() * (maxDelay - minDelay);
                    console.log(`Save prompt will show after ${naturalListening.savePromptDelay}ms delay`);
                    app.debugger?.log('natural:savePromptScheduled', {
                        trackIndex,
                        delayMs: Math.round(naturalListening.savePromptDelay)
                    });
                }
            } else {
                naturalListening.shouldShowSavePrompt = false;
            }

            console.log(`Natural listening: Skip at ${skipPercent.toFixed(1)}% (${naturalListening.skipThreshold}ms)`);
            app.debugger?.setExtraMetrics({
                'Skip Target (%)': `${skipPercent.toFixed(1)}%`,
                'Skip Target (ms)': `${Math.round(naturalListening.skipThreshold)}`,
                'Save Prompt Planned': naturalListening.shouldShowSavePrompt ? 'Yes' : 'No',
                'Skip Triggered': 'Not yet'
            });
            app.debugger?.log('natural:configure', {
                trackIndex,
                skipPercent: Number(skipPercent.toFixed(1)),
                skipThreshold: Math.round(naturalListening.skipThreshold),
                savePromptPlanned: naturalListening.shouldShowSavePrompt
            });
        }

        // Check if we should skip to next track
        function checkNaturalSkip(currentPosition) {
            if (currentPosition >= naturalListening.skipThreshold) {
                console.log('Natural skip triggered - advancing to next track');
                app.debugger?.log('natural:skipTrigger', {
                    position: Math.round(currentPosition),
                    threshold: Math.round(naturalListening.skipThreshold)
                });
                app.debugger?.setExtraMetrics({ 'Skip Triggered': new Date().toLocaleTimeString() });
                if (app.playback && app.playback.advanceTrack) {
                    const advancePromise = app.playback.advanceTrack();
                    if (advancePromise?.catch) {
                        advancePromise.catch(error => {
                            app.debugger?.log('playback:advanceError', { message: error.message });
                        });
                    }
                }
                return true;
            }
            return false;
        }

        // Show save prompt after track ends
        function showSavePrompt(track) {
            if (!naturalListening.shouldShowSavePrompt || naturalListening.savePromptShown) {
                return;
            }
            
            naturalListening.savePromptShown = true;
            
            setTimeout(async () => {
                try {
                    // Create a natural-looking save prompt
                    const savePrompt = document.createElement('div');
                    savePrompt.style.cssText = `
                        position: fixed;
                        bottom: 120px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(30, 30, 30, 0.95);
                        backdrop-filter: blur(10px);
                        color: white;
                        padding: 16px 20px;
                        border-radius: 25px;
                        font-size: 14px;
                        z-index: 1001;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        border: 1px solid rgba(255,255,255,0.1);
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        max-width: 90%;
                        animation: slideUpFade 0.3s ease-out;
                    `;
                    
                    // Add slide up animation
                    if (!document.querySelector('#savePromptStyle')) {
                        const style = document.createElement('style');
                        style.id = 'savePromptStyle';
                        style.textContent = `
                            @keyframes slideUpFade {
                                0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                                100% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // Heart icon
                    const heartIcon = document.createElement('div');
                    heartIcon.innerHTML = '🤍';
                    heartIcon.style.fontSize = '18px';
                    
                    // Track info
                    const trackInfo = document.createElement('div');
                    trackInfo.innerHTML = `
                        <div style="font-weight: 500; margin-bottom: 2px;">${track.name}</div>
                        <div style="font-size: 12px; opacity: 0.7;">${track.artists?.[0]?.name || 'Unknown Artist'}</div>
                    `;
                    
                    // Save button
                    const saveButton = document.createElement('button');
                    saveButton.textContent = 'Save';
                    saveButton.style.cssText = `
                        background: #1db954;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    `;
                    
                    // Close button
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '×';
                    closeButton.style.cssText = `
                        background: none;
                        color: rgba(255,255,255,0.7);
                        border: none;
                        font-size: 18px;
                        cursor: pointer;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: 8px;
                    `;
                    
                    savePrompt.appendChild(heartIcon);
                    savePrompt.appendChild(trackInfo);
                    savePrompt.appendChild(saveButton);
                    savePrompt.appendChild(closeButton);

                    document.body.appendChild(savePrompt);
                    app.debugger?.log('natural:savePromptShown', {
                        trackId: track.id,
                        trackName: track.name
                    });
                    
                    // Button interactions
                    saveButton.addEventListener('mouseenter', () => {
                        saveButton.style.background = '#1ed760';
                        saveButton.style.transform = 'scale(1.05)';
                    });
                    
                    saveButton.addEventListener('mouseleave', () => {
                        saveButton.style.background = '#1db954';
                        saveButton.style.transform = 'scale(1)';
                    });
                    
                    // Save functionality
                    saveButton.addEventListener('click', async () => {
                        try {
                            app.debugger?.log('natural:savePromptAccepted', {
                                trackId: track.id,
                                trackName: track.name
                            });
                            await app.client.saveTrack(track.id);

                            // Update button to show success
                            heartIcon.innerHTML = '💚';
                            saveButton.textContent = 'Saved!';
                            saveButton.style.background = '#1ed760';
                            saveButton.disabled = true;

                            console.log(`Track saved: ${track.name}`);
                            app.debugger?.log('natural:savePromptSaved', {
                                trackId: track.id
                            });

                            // Remove after showing success
                            setTimeout(() => {
                                if (savePrompt.parentNode) {
                                    savePrompt.style.animation = 'slideDownFade 0.3s ease-out';
                                    setTimeout(() => {
                                        if (savePrompt.parentNode) {
                                            savePrompt.parentNode.removeChild(savePrompt);
                                        }
                                    }, 300);
                                }
                            }, 2000);
                            
                        } catch (error) {
                            console.error('Failed to save track:', error);
                            saveButton.textContent = 'Error';
                            saveButton.style.background = '#ff4444';
                            app.debugger?.log('natural:savePromptError', {
                                trackId: track.id,
                                message: error.message
                            });
                        }
                    });
                    
                    // Close functionality
                    const closeSavePrompt = () => {
                        if (savePrompt.parentNode) {
                            savePrompt.style.animation = 'slideDownFade 0.3s ease-out';
                            setTimeout(() => {
                                if (savePrompt.parentNode) {
                                    savePrompt.parentNode.removeChild(savePrompt);
                                }
                            }, 300);
                        }
                    };
                    
                    closeButton.addEventListener('click', closeSavePrompt);
                    
                    // Auto-close after 8 seconds
                    setTimeout(closeSavePrompt, 8000);
                    
                    // Add slide down animation
                    if (!document.querySelector('#slideDownStyle')) {
                        const slideStyle = document.createElement('style');
                        slideStyle.id = 'slideDownStyle';
                        slideStyle.textContent = `
                            @keyframes slideDownFade {
                                0% { opacity: 1; transform: translateX(-50%) translateY(0); }
                                100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                            }
                        `;
                        document.head.appendChild(slideStyle);
                    }
                    
                } catch (error) {
                    console.error('Failed to show save prompt:', error);
                    app.debugger?.log('natural:savePromptFailure', {
                        trackId: track.id,
                        message: error.message
                    });
                }
            }, naturalListening.savePromptDelay);
        }

        // High precision timing clock
        class TimingClock {
            constructor() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
                this.performanceOffset = 0; // Calibration for audio latency
            }

            start() {
                this.startTime = performance.now();
                this.pausedTime = 0;
                this.isPaused = false;
            }

            pause() {
                if (!this.isPaused && this.startTime) {
                    this.isPaused = true;
                    this.pausedTime = performance.now();
                }
            }

            resume() {
                if (this.isPaused && this.pausedTime > 0) {
                    const pauseDuration = performance.now() - this.pausedTime;
                    this.startTime += pauseDuration;
                    this.isPaused = false;
                    this.pausedTime = 0;
                }
            }

            getTime() {
                if (!this.startTime) return 0;
                if (this.isPaused) {
                    return this.pausedTime - this.startTime + this.performanceOffset;
                }
                return performance.now() - this.startTime + this.performanceOffset;
            }

            setCalibration(offsetMs) {
                this.performanceOffset = offsetMs;
            }

            reset() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
            }
        }

        // Progress tracking
        let initProgress = 0;
        const initSteps = 7; // Reduced steps for native playback

        // Add this function for the new loading screen
        function continueToGame() {
            // Hide Spotify setup step
            document.getElementById('spotifySetup').classList.add('hidden');
            
            // Show loading step
            document.getElementById('gameLoading').classList.remove('hidden');
            
            // Start the actual game initialization
            // This will call your existing initGame() function
            setTimeout(() => {
                initGame();
            }, 500);
        }
        
        // Make function global so it can be called from onclick
        window.continueToGame = continueToGame;

        // Update progress display
        function updateProgress(step, message) {
            initProgress = step;
            const percentage = Math.round((step / initSteps) * 100);
            updateShieldMessage(message);
            app.debugger?.log('init:progress', { step, message, percentage });
            app.debugger?.setExtraMetrics({ 'Initialization': `${percentage}% - ${message}` });
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
        }

        // Enhanced updateShieldMessage function
        function updateShieldMessage(message) {
            const element = document.getElementById('shieldMessage');
            const noteElement = document.getElementById('loadingNote');
            
            if (element) {
                element.textContent = message;
            }
            
            // Update the loading note with more specific messages
            if (noteElement) {
                switch (message) {
                    case 'Connecting to Spotify...':
                        noteElement.textContent = 'Establishing connection with your Spotify account...';
                        break;
                    case 'Checking Premium and finding devices...':
                        noteElement.textContent = 'Looking for your active Spotify device...';
                        break;
                    case 'Connecting to native Spotify app...':
                        noteElement.textContent = 'Connecting to your Spotify app for music playback...';
                        break;
                    case 'Initializing game components...':
                        noteElement.textContent = 'Setting up the rhythm game engine...';
                        break;
                    case 'Setting up event handlers...':
                        noteElement.textContent = 'Configuring game controls and interactions...';
                        break;
                    case 'Preparing game session...':
                        noteElement.textContent = 'Creating your personalized playlist and charts...';
                        break;
                    case 'Ready!':
                        noteElement.textContent = 'Everything is ready! Starting your rhythm game...';
                        break;
                    default:
                        noteElement.textContent = 'Setting up your rhythm game experience...';
                }
            }
            
            app.debugger?.log('ui:shieldMessage', { message });
        }

        // Auto-calibration function
        async function autoCalibrate() {
            try {
                // Get tempo information from the current track or MIDI data
                let targetOffset = 0;
                if (app.engine && app.engine.currentChart && app.engine.currentChart.metadata.source === 'midi') {
                    // For MIDI tracks, use a small positive offset to account for processing
                    targetOffset = 15; // 15ms ahead to compensate for processing delay
                } else {
                    // For other tracks, use audio analysis or default
                    const playbackState = await app.client.getPlaybackState();
                    if (playbackState && playbackState.item) {
                        try {
                            const features = await app.client.getAudioFeatures(playbackState.item.id);
                            const feature = Array.isArray(features?.audio_features)
                                ? features.audio_features[0]
                                : features;
                            const tempo = feature?.tempo || 120;
                            
                            // Calculate offset based on tempo (slower songs need more lookahead)
                            if (tempo < 90) {
                                targetOffset = 25; // Slower songs
                            } else if (tempo > 140) {
                                targetOffset = 10; // Faster songs
                            } else {
                                targetOffset = 15; // Medium tempo
                            }
                        } catch (error) {
                            console.warn('Could not get audio features, using default offset');
                            targetOffset = 15;
                        }
                    }
                }

                // Apply the calculated offset
                if (app.playback) {
                    app.playback.setCalibrationOffset(targetOffset);
                    console.log(`Auto-calibration set to ${targetOffset}ms`);
                    app.debugger?.log('calibration:applied', {
                        offset: targetOffset,
                        strategy: app.engine?.currentChart?.metadata?.source === 'midi' ? 'midi-default' : 'tempo-analysis'
                    });
                    app.debugger?.setExtraMetrics({ 'Calibration Offset': `${targetOffset}ms` });
                }
            } catch (error) {
                console.warn('Auto-calibration failed:', error);
                // Use default offset
                if (app.playback) {
                    app.playback.setCalibrationOffset(15);
                }
                app.debugger?.log('calibration:error', {
                    message: error.message
                });
                app.debugger?.setExtraMetrics({ 'Calibration Offset': '15ms (fallback)' });
            }
        }

        // Initialize the game
        async function initGame() {
            try {
                app.debugger?.log('init:start');
                updateProgress(0, 'Validating session...');

                // Validate bootstrap nonce
                const urlParams = new URLSearchParams(window.location.search);
                const bootstrap = urlParams.get('bootstrap');
                const storedNonce = sessionStorage.getItem('bootstrap_nonce');

                if (!bootstrap || bootstrap !== storedNonce) {
                    throw new Error('Invalid session. Please start over.');
                }
                sessionStorage.removeItem('bootstrap_nonce');

                updateProgress(1, 'Connecting to Spotify...');

                // Initialize Spotify client
                app.client = new SpotifyClient();
                await app.client.initialize();
                app.debugger?.log('init:clientReady');

                updateProgress(2, 'Checking Premium and finding devices...');
                await checkPremiumStatus();
                app.debugger?.log('init:devicesChecked');

                updateProgress(3, 'Connecting to native Spotify app...');

                // Use native Spotify playback instead of Web Playback SDK
                app.playback = new NativeSpotifyPlayback(app.client);
                try {
                    const deviceInfo = await app.playback.initialize();
                    app.debugger?.log('init:playbackReady', {
                        deviceId: deviceInfo?.id,
                        deviceName: deviceInfo?.name
                    });
                    if (deviceInfo?.name) {
                        app.debugger?.setExtraMetrics({ 'Active Device': deviceInfo.name });
                    }
                } catch (error) {
                    if (error.message && error.message.includes('device')) {
                        throw new Error('Unable to connect to Spotify. Please make sure Spotify is open and playing on your device, then refresh this page.');
                    }
                    throw error;
                }

                updateProgress(4, 'Initializing game components...');

                // Initialize timing clock
                app.timingClock = new TimingClock();
                app.debugger?.log('init:timingClockReady');

                // Initialize game components in parallel
                const canvas = document.getElementById('gameCanvas');
                await Promise.all([
                    new Promise(resolve => {
                        app.engine = new GameEngine();
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.input = new GameInput(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.render = new GameRender(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.ui = new GameUI();
                        resolve();
                    })
                ]);
                app.debugger?.log('init:componentsReady');

                app.debugger?.attach({
                    engine: app.engine,
                    playback: app.playback,
                    timingClock: app.timingClock
                });

                // Wait for MIDI files to load
                console.log('Waiting for MIDI files to load...');
                await new Promise(resolve => {
                    const checkMidi = () => {
                        const availableTracks = app.engine.midiGenerator.getAvailableTracks();
                        if (availableTracks.length > 0) {
                            console.log(`MIDI loaded for ${availableTracks.length} tracks:`, availableTracks);
                            resolve();
                        } else {
                            console.log('Still waiting for MIDI files...');
                            setTimeout(checkMidi, 500);
                        }
                    };
                    checkMidi();
                });
                app.debugger?.log('init:midiReady');

                // Override config for higher note density
                if (window.config && window.config.CHART) {
                    window.config.CHART.DENSITY_MULTIPLIERS = {
                        EASY: 1.0,
                        NORMAL: 1.5,   // Increased from default
                        HARD: 2.0      // Increased from default
                    };
                    window.config.CHART.MIN_NOTE_SPACING = 100; // Reduced from default to allow closer notes
                    console.log('Note density increased for more challenging gameplay');
                }

                updateProgress(5, 'Setting up event handlers...');
                setupEventHandlers();
                app.debugger?.log('init:handlersReady');

                updateProgress(6, 'Preparing game session...');
                await startGameSession();
                app.debugger?.log('init:sessionReady');

                updateProgress(7, 'Ready!');

                // Auto-calibrate based on tempo instead of showing manual calibration
                await autoCalibrate();

                // Enable debug mode toggle (press D key)
                setupDebugMode();
                app.debugger?.log('init:debugReady');

                // Small delay to show completion
                await new Promise(resolve => setTimeout(resolve, 500));

                // Hide input shield and start game
                document.getElementById('inputShield').style.display = 'none';
                app.isInitialized = true;
                startGameLoop();
                app.debugger?.log('init:complete');
                app.debugger?.setExtraMetrics({ 'Initialization': 'Complete' });

            } catch (error) {
                console.error('Game initialization failed:', error);
                
                // Enhanced error handling with Spotify-specific messages
                let errorMessage = error.message;
                
                if (error.message.includes('device') || error.message.includes('Spotify')) {
                    errorMessage = `
Unable to connect to Spotify. Please make sure:

1. Spotify is open on your device
2. You're playing music (any song is fine)  
3. You have a stable internet connection
4. You have Spotify Premium

Then refresh this page and try again.
                    `.trim();
                }
                
                showError(errorMessage);
                app.debugger?.log('init:error', { message: error.message });
                app.debugger?.setExtraMetrics({ 'Initialization': 'Failed' });
            }
        }
