<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>RHYTHM - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        /* Defensive CSS to hide any stray media elements */
        audio, video, iframe, object, embed {
            display: none !important;
            visibility: hidden !important;
        }

        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .input-shield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            touch-action: none;
        }

        .shield-content {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            width: 90%;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin: 10px auto;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1db954;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            font-size: 16px;
            pointer-events: none;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .score {
            font-weight: bold;
            font-size: 18px;
        }

        .combo {
            font-size: 14px;
            opacity: 0.8;
        }

        .track-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .track-name {
            font-weight: bold;
            font-size: 16px;
        }

        .track-artist {
            font-size: 14px;
            opacity: 0.8;
        }

        .required-threshold {
            font-size: 12px;
            color: #1db954;
            margin-top: 5px;
        }

        .health-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 100%;
        }

        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 1001;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .results-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1db954, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 2000;
        }

        .results-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }

        .results-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px;
        }

        .track-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .track-result:last-child {
            border-bottom: none;
        }

        .track-result-name {
            font-weight: bold;
            font-size: 14px;
            flex: 1;
            text-align: left;
        }

        .track-result-score {
            font-size: 12px;
            text-align: right;
            margin-left: 10px;
        }

        .completion-code {
            background: rgba(29, 185, 84, 0.2);
            border: 1px solid rgba(29, 185, 84, 0.5);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 2rem;
            text-align: center;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }

        .back-link {
            color: #1db954;
            text-decoration: none;
            font-size: 16px;
            margin-top: 1rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff4444, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 3000;
            text-align: center;
        }

        .error-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .error-message {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            max-width: 400px;
        }

        .timing-debug {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 4px;
            z-index: 200;
            display: none;
        }

        /* Mobile Debug Console */
        .debug-console {
            position: fixed;
            top: 100px;
            left: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            color: black;
            padding: 10px;
            font-size: 11px;
            font-family: monospace;
            z-index: 9999;
            display: none;
            max-height: 250px;
            overflow-y: auto;
            border-radius: 8px;
            border: 2px solid #ff6b35;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .debug-header {
            background: #ff6b35;
            color: white;
            padding: 5px 10px;
            margin: -10px -10px 10px -10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-close {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
        }

        .debug-toggle {
            position: fixed;
            top: 60px;
            right: 10px;
            background: #ff6b35;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 10000;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        /* Spotify Setup Notification */
        .spotify-notification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-out;
        }

        .notification-card {
            background: linear-gradient(135deg, #1db954, #1ed760);
            border-radius: 20px;
            padding: 40px;
            max-width: 450px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
        }

        .notification-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }

        .notification-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: white;
        }

        .notification-message {
            font-size: 1.1rem;
            margin-bottom: 2rem;
            color: rgba(255,255,255,0.9);
            line-height: 1.5;
        }

        .notification-steps {
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            text-align: left;
        }

        .notification-step {
            display: flex;
            align-items: center;
            margin: 12px 0;
            font-size: 1rem;
        }

        .step-number {
            background: rgba(255,255,255,0.9);
            color: #1db954;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .notification-buttons {
            display: flex;
            gap: 12px;
            margin-top: 2rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .notif-button {
            background: rgba(255,255,255,0.9);
            color: #1db954;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
        }

        .notif-button:hover {
            background: white;
            transform: translateY(-1px);
        }

        .notif-button.secondary {
            background: rgba(0,0,0,0.3);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .notif-button.secondary:hover {
            background: rgba(0,0,0,0.5);
        }

        .notif-button:disabled {
            background: rgba(255,255,255,0.5);
            cursor: not-allowed;
            transform: none;
        }

        .checking-status {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            color: rgba(255,255,255,0.8);
        }

        .checking-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: scale(0.9); }
            100% { opacity: 1; transform: scale(1); }
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.9); }
        }
    </style>
</head>
<body>
    <!-- Mobile Debug Console -->
    <button class="debug-toggle" onclick="toggleDebugConsole()">Debug</button>
    <div class="debug-console" id="debugConsole">
        <div class="debug-header">
            Debug Console
            <button class="debug-close" onclick="toggleDebugConsole()">√ó</button>
        </div>
        <div id="debugInfo">Initializing debug console...<br></div>
    </div>

    <!-- Game Canvas -->
    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Game HUD -->
        <div class="hud">
            <div class="hud-top">
                <div class="score" id="scoreDisplay">0</div>
                <div class="combo" id="comboDisplay">0x</div>
            </div>
            <div class="track-info">
                <div class="track-name" id="trackName">Loading...</div>
                <div class="track-artist" id="trackArtist"></div>
                <div class="required-threshold" id="requiredThreshold"></div>
            </div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill"></div>
            </div>
        </div>

        <!-- Timing Debug (hidden by default) -->
        <div class="timing-debug" id="timingDebug">
            <div id="timingInfo">Timing Info</div>
        </div>

        <!-- Input Shield (shown during loading) -->
        <div class="input-shield" id="inputShield">
            <div class="shield-content">
                <div class="spinner"></div>
                <div style="margin-top: 20px;" id="shieldMessage">Initializing game...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Screen -->
    <div class="results-screen" id="resultsScreen">
        <div class="results-title">Session Complete</div>
        <div class="results-stats" id="resultsStats">
            <!-- Track results will be populated here -->
        </div>
        <div class="completion-code">
            <div style="margin-bottom: 8px; font-weight: bold;">Completion Code:</div>
            <div id="completionCode">RHYTHM-20241217-A1B2C3D4</div>
        </div>
        <a href="/" class="back-link">Play Again</a>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <div class="error-title">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong</div>
        <a href="/" class="back-link">Back to Start</a>
    </div>

    <script>
        // Mobile Debug Console Functions
        let debugCount = 0;
        function mobileLog(message) {
            console.log(message);
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                const timestamp = new Date().toLocaleTimeString();
                debugDiv.innerHTML += `[${timestamp}] ${message}<br>`;
                debugDiv.scrollTop = debugDiv.scrollHeight;
                debugCount++;
                
                // Auto-show debug console if there are errors
                if (message.includes('ERROR') || message.includes('FAILED')) {
                    document.getElementById('debugConsole').style.display = 'block';
                }
            }
        }

        function toggleDebugConsole() {
            const console = document.getElementById('debugConsole');
            console.style.display = console.style.display === 'none' ? 'block' : 'none';
        }

        // Enhanced error catching
        window.addEventListener('error', (e) => {
            mobileLog(`ERROR: ${e.message} at ${e.filename}:${e.lineno}:${e.colno}`);
        });

        window.addEventListener('unhandledrejection', (e) => {
            mobileLog(`PROMISE ERROR: ${e.reason}`);
        });

        // Log initial page load
        mobileLog('Page loaded, starting initialization...');
    </script>

    <script type="module">
        import { config, generateCompletionCode, getFinalTrackList } from './config.js';
        import { PKCE } from './auth-pkce.js';
        import { SpotifyClient } from './spotify-client.js';
        import { NativeSpotifyPlayback } from './native-spotify-playback.js';
        import { GameEngine } from './game-engine.js';
        import { GameInput } from './game-input.js';
        import { GameRender } from './game-render.js';
        import { GameUI } from './game-ui.js';
        import { MidiChartGenerator } from './midi-chart-generator.js';

        // Log module imports
        mobileLog('Modules imported successfully');

        // Global app state
        let app = {
            auth: null,
            client: null,
            playback: null,
            engine: null,
            input: null,
            render: null,
            ui: null,
            isInitialized: false,
            gameLoopId: null,
            timingClock: null
        };

        // Natural listening behavior state
        let naturalListening = {
            skipThreshold: 0,
            shouldShowSavePrompt: false,
            savePromptShown: false,
            savePromptDelay: 0,
            currentTrackIndex: 0,
            trackStartTime: 0
        };

        // Initialize natural listening for a track
        function initializeNaturalListening(trackIndex, trackDuration) {
            const minPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MIN;
            const maxPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MAX;
            const skipPercent = minPercent + Math.random() * (maxPercent - minPercent);
            
            naturalListening.skipThreshold = (skipPercent / 100) * trackDuration;
            naturalListening.currentTrackIndex = trackIndex;
            naturalListening.trackStartTime = Date.now();
            naturalListening.savePromptShown = false;
            
            if (trackIndex === config.NATURAL_LISTENING.SAVE_PROMPT_TRACK - 1) {
                naturalListening.shouldShowSavePrompt = Math.random() < config.NATURAL_LISTENING.SAVE_PROMPT_PROBABILITY;
                if (naturalListening.shouldShowSavePrompt) {
                    const minDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MIN;
                    const maxDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MAX;
                    naturalListening.savePromptDelay = minDelay + Math.random() * (maxDelay - minDelay);
                    mobileLog(`Save prompt will show after ${naturalListening.savePromptDelay}ms delay`);
                }
            } else {
                naturalListening.shouldShowSavePrompt = false;
            }
            
            mobileLog(`Natural listening: Skip at ${skipPercent.toFixed(1)}% (${naturalListening.skipThreshold}ms)`);
        }

        // Check if we should skip to next track
        function checkNaturalSkip(currentPosition) {
            if (currentPosition >= naturalListening.skipThreshold) {
                mobileLog('Natural skip triggered - advancing to next track');
                if (app.playback && app.playback.advanceTrack) {
                    app.playback.advanceTrack();
                }
                return true;
            }
            return false;
        }

        // Show save prompt after track ends
        function showSavePrompt(track) {
            if (!naturalListening.shouldShowSavePrompt || naturalListening.savePromptShown) {
                return;
            }
            
            naturalListening.savePromptShown = true;
            
            setTimeout(async () => {
                try {
                    const savePrompt = document.createElement('div');
                    savePrompt.style.cssText = `
                        position: fixed;
                        bottom: 120px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(30, 30, 30, 0.95);
                        backdrop-filter: blur(10px);
                        color: white;
                        padding: 16px 20px;
                        border-radius: 25px;
                        font-size: 14px;
                        z-index: 1001;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        border: 1px solid rgba(255,255,255,0.1);
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        max-width: 90%;
                        animation: slideUpFade 0.3s ease-out;
                    `;
                    
                    if (!document.querySelector('#savePromptStyle')) {
                        const style = document.createElement('style');
                        style.id = 'savePromptStyle';
                        style.textContent = `
                            @keyframes slideUpFade {
                                0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                                100% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    const heartIcon = document.createElement('div');
                    heartIcon.innerHTML = 'ü§ç';
                    heartIcon.style.fontSize = '18px';
                    
                    const trackInfo = document.createElement('div');
                    trackInfo.innerHTML = `
                        <div style="font-weight: 500; margin-bottom: 2px;">${track.name}</div>
                        <div style="font-size: 12px; opacity: 0.7;">${track.artists?.[0]?.name || 'Unknown Artist'}</div>
                    `;
                    
                    const saveButton = document.createElement('button');
                    saveButton.textContent = 'Save';
                    saveButton.style.cssText = `
                        background: #1db954;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    `;
                    
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '√ó';
                    closeButton.style.cssText = `
                        background: none;
                        color: rgba(255,255,255,0.7);
                        border: none;
                        font-size: 18px;
                        cursor: pointer;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: 8px;
                    `;
                    
                    savePrompt.appendChild(heartIcon);
                    savePrompt.appendChild(trackInfo);
                    savePrompt.appendChild(saveButton);
                    savePrompt.appendChild(closeButton);
                    
                    document.body.appendChild(savePrompt);
                    
                    saveButton.addEventListener('click', async () => {
                        try {
                            await app.client.saveTrack(track.id);
                            heartIcon.innerHTML = 'üíö';
                            saveButton.textContent = 'Saved!';
                            saveButton.style.background = '#1ed760';
                            saveButton.disabled = true;
                            
                            setTimeout(() => {
                                if (savePrompt.parentNode) {
                                    savePrompt.parentNode.removeChild(savePrompt);
                                }
                            }, 2000);
                            
                        } catch (error) {
                            mobileLog('Failed to save track: ' + error.message);
                            saveButton.textContent = 'Error';
                            saveButton.style.background = '#ff4444';
                        }
                    });
                    
                    const closeSavePrompt = () => {
                        if (savePrompt.parentNode) {
                            savePrompt.parentNode.removeChild(savePrompt);
                        }
                    };
                    
                    closeButton.addEventListener('click', closeSavePrompt);
                    setTimeout(closeSavePrompt, 8000);
                    
                } catch (error) {
                    mobileLog('Failed to show save prompt: ' + error.message);
                }
            }, naturalListening.savePromptDelay);
        }

        // High precision timing clock
        class TimingClock {
            constructor() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
                this.performanceOffset = 0;
            }

            start() {
                this.startTime = performance.now();
                this.pausedTime = 0;
                this.isPaused = false;
            }

            pause() {
                if (!this.isPaused && this.startTime) {
                    this.isPaused = true;
                    this.pausedTime = performance.now();
                }
            }

            resume() {
                if (this.isPaused && this.pausedTime > 0) {
                    const pauseDuration = performance.now() - this.pausedTime;
                    this.startTime += pauseDuration;
                    this.isPaused = false;
                    this.pausedTime = 0;
                }
            }

            getTime() {
                if (!this.startTime) return 0;
                if (this.isPaused) {
                    return this.pausedTime - this.startTime + this.performanceOffset;
                }
                return performance.now() - this.startTime + this.performanceOffset;
            }

            setCalibration(offsetMs) {
                this.performanceOffset = offsetMs;
            }

            reset() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
            }
        }

        // Progress tracking
        let initProgress = 0;
        const initSteps = 7;

        function updateProgress(step, message) {
            initProgress = step;
            const percentage = Math.round((step / initSteps) * 100);
            updateShieldMessage(message);
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
            mobileLog(`Progress ${step}/${initSteps}: ${message}`);
        }

        // Auto-calibration function
        async function autoCalibrate() {
            try {
                let targetOffset = 0;
                if (app.engine && app.engine.currentChart && app.engine.currentChart.metadata.source === 'midi') {
                    targetOffset = 15;
                } else {
                    const track = await app.client.getCurrentPlaybackState();
                    if (track && track.item) {
                        try {
                            const features = await app.client.getAudioFeatures(track.item.id);
                            const tempo = features.tempo || 120;
                            
                            if (tempo < 90) {
                                targetOffset = 25;
                            } else if (tempo > 140) {
                                targetOffset = 10;
                            } else {
                                targetOffset = 15;
                            }
                        } catch (error) {
                            mobileLog('Could not get audio features, using default offset');
                            targetOffset = 15;
                        }
                    }
                }

                if (app.playback) {
                    app.playback.setCalibrationOffset(targetOffset);
                    mobileLog(`Auto-calibration set to ${targetOffset}ms`);
                }
            } catch (error) {
                mobileLog('Auto-calibration failed: ' + error.message);
                if (app.playback) {
                    app.playback.setCalibrationOffset(15);
                }
            }
        }

        // Spotify Setup Notification Functions
        function showSpotifySetupNotification(customMessage = null, isPremiumError = false) {
            const notification = document.createElement('div');
            notification.className = 'spotify-notification';
            
            const title = isPremiumError ? 'Spotify Premium Required' : 'Open Spotify First!';
            const message = customMessage || 'To play RHYTHM, we need Spotify running on one of your devices.';
            const steps = isPremiumError ? 
                '<div style="text-align: center; padding: 20px;">This game requires Spotify Premium to control playback.<br><br><a href="https://spotify.com/premium" target="_blank" style="color: white; text-decoration: underline;">Upgrade to Premium</a></div>' :
                `<div class="notification-steps">
                    <div class="notification-step">
                        <div class="step-number">1</div>
                        <div>Open Spotify on your phone, computer, or tablet</div>
                    </div>
                    <div class="notification-step">
                        <div class="step-number">2</div>
                        <div>Play any song (you can pause it right after)</div>
                    </div>
                    <div class="notification-step">
                        <div class="step-number">3</div>
                        <div>Come back here and click "I'm Ready"</div>
                    </div>
                </div>`;
            
            notification.innerHTML = `
                <div class="notification-card">
                    <div class="notification-icon">üéµ</div>
                    <div class="notification-title">${title}</div>
                    <div class="notification-message">${message}</div>
                    
                    ${steps}
                    
                    <div class="checking-status" id="checkingStatus" style="display: none;">
                        <div class="checking-spinner"></div>
                        <div>Checking for Spotify...</div>
                    </div>
                    
                    <div class="notification-buttons">
                        ${isPremiumError ? 
                            `<button class="notif-button secondary" onclick="window.location.href='/'">Back to Start</button>` :
                            `<button class="notif-button" onclick="checkSpotifyAndContinue()">I'm Ready!</button>
                             <button class="notif-button secondary" onclick="closeSpotifyNotification()">Cancel</button>`
                        }
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            mobileLog('Showing Spotify setup notification: ' + title);
        }

        window.checkSpotifyAndContinue = async function() {
            const statusEl = document.getElementById('checkingStatus');
            const buttons = document.querySelectorAll('.notif-button');
            
            statusEl.style.display = 'flex';
            buttons.forEach(btn => btn.disabled = true);
            mobileLog('Checking for Spotify devices...');
            
            try {
                const devices = await app.client.request('/v1/me/player/devices');
                
                if (!devices.devices || devices.devices.length === 0) {
                    throw new Error('No Spotify devices found. Make sure Spotify is open!');
                }
                
                const activeDevice = devices.devices.find(d => d.is_active);
                if (!activeDevice) {
                    throw new Error('Please play a song in Spotify first to activate a device.');
                }
                
                statusEl.innerHTML = '<div class="checking-spinner"></div><div>Found Spotify! Continuing...</div>';
                mobileLog(`Found ${devices.devices.length} devices, continuing...`);
                
                setTimeout(() => {
                    closeSpotifyNotification();
                    continueGameInitialization();
                }, 1500);
                
            } catch (error) {
                mobileLog('Spotify check failed: ' + error.message);
                statusEl.innerHTML = `<div style="color: #ffaa00;">‚ùå ${error.message}</div>`;
                
                setTimeout(() => {
                    statusEl.style.display = 'none';
                    buttons.forEach(btn => btn.disabled = false);
                }, 3000);
            }
        };

        window.closeSpotifyNotification = function() {
            const notification = document.querySelector('.spotify-notification');
            if (notification) {
                notification.style.animation = 'fadeOut 0.3s ease-out';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }
            mobileLog('Closed Spotify notification');
        };

        let continueInitAfterSpotify = null;

        function continueGameInitialization() {
            mobileLog('Continuing game initialization after Spotify check');
            if (continueInitAfterSpotify) {
                continueInitAfterSpotify();
            }
        }

        // Initialize the game
        async function initGame() {
            try {
                mobileLog('Starting game initialization...');
                updateProgress(0, 'Validating session...');

                const urlParams = new URLSearchParams(window.location.search);
                const bootstrap = urlParams.get('bootstrap');
                const storedNonce = sessionStorage.getItem('bootstrap_nonce');

                if (!bootstrap || bootstrap !== storedNonce) {
                    throw new Error('Invalid session. Please start over.');
                }
                sessionStorage.removeItem('bootstrap_nonce');
                mobileLog('Session validation passed');

                updateProgress(1, 'Connecting to Spotify...');

                app.client = new SpotifyClient();
                await app.client.initialize();
                mobileLog('Spotify client initialized');

                updateProgress(2, 'Checking Premium and finding devices...');
                await checkPremiumStatus();
                mobileLog('Premium status checked');

                updateProgress(3, 'Connecting to native Spotify app...');

                app.playback = new NativeSpotifyPlayback(app.client);
                try {
                    await app.playback.initialize();
                    mobileLog('Native Spotify playback initialized');
                } catch (error) {
                    if (error.message && error.message.includes('device')) {
                        throw new Error('Unable to connect to Spotify. Please make sure Spotify is open and playing on your device, then refresh this page.');
                    }
                    throw error;
                }

                updateProgress(4, 'Initializing game components...');

                app.timingClock = new TimingClock();
                mobileLog('Timing clock created');

                const canvas = document.getElementById('gameCanvas');
                await Promise.all([
                    new Promise(resolve => {
                        app.engine = new GameEngine();
                        mobileLog('Game engine created');
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.input = new GameInput(canvas);
                        mobileLog('Game input created');
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.render = new GameRender(canvas);
                        mobileLog('Game render created');
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.ui = new GameUI();
                        mobileLog('Game UI created');
                        resolve();
                    })
                ]);
                
                mobileLog('Waiting for MIDI files to load...');
                await Promise.race([
                    new Promise(resolve => {
                        const checkMidi = () => {
                            const availableTracks = app.engine.midiGenerator.getAvailableTracks();
                            if (availableTracks.length > 0) {
                                mobileLog(`MIDI loaded for ${availableTracks.length} tracks: ${availableTracks.join(', ')}`);
                                resolve();
                            } else {
                                mobileLog('Still waiting for MIDI files...');
                                setTimeout(checkMidi, 500);
                            }
                        };
                        checkMidi();
                    }),
                    new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('MIDI loading timeout')), 10000);
                    })
                ]);

                if (window.config && window.config.CHART) {
                    window.config.CHART.DENSITY_MULTIPLIERS = {
                        EASY: 1.0,
                        NORMAL: 1.5,
                        HARD: 2.0
                    };
                    window.config.CHART.MIN_NOTE_SPACING = 100;
                    mobileLog('Note density increased for more challenging gameplay');
                }

                updateProgress(5, 'Setting up event handlers...');
                setupEventHandlers();
                mobileLog('Event handlers set up');

                updateProgress(6, 'Preparing game session...');
                await startGameSession();
                mobileLog('Game session started');

                updateProgress(7, 'Ready!');

                await autoCalibrate();
                setupDebugMode();

                await new Promise(resolve => setTimeout(resolve, 500));

                document.getElementById('inputShield').style.display = 'none';
                app.isInitialized = true;
                startGameLoop();
                mobileLog('Game fully initialized and running!');

            } catch (error) {
                mobileLog('GAME INIT FAILED: ' + error.message);
                console.error('Game initialization failed:', error);
                showError(error.message || 'Failed to initialize game');
            }
        }

        async function checkPremiumStatus() {
            return new Promise(async (resolve, reject) => {
                try {
                    mobileLog('Checking for Spotify devices...');
                    const devices = await app.client.request('/v1/me/player/devices');
                    
                    if (!devices.devices || devices.devices.length === 0) {
                        mobileLog('No devices found, showing setup notification');
                        continueInitAfterSpotify = resolve;
                        showSpotifySetupNotification('No Spotify devices found. Please open Spotify on your phone or computer.');
                        return;
                    }
                    
                    const hasActiveDevice = devices.devices.some(device => device.is_active);
                    if (!hasActiveDevice) {
                        mobileLog('No active device found, showing setup notification');
                        continueInitAfterSpotify = resolve;
                        showSpotifySetupNotification('No active Spotify device found. Please play a song in Spotify first.');
                        return;
                    }
                    
                    mobileLog(`Found ${devices.devices.length} Spotify devices, ${devices.devices.filter(d => d.is_active).length} active`);
                    resolve();
                    
                } catch (error) {
                    if (error.status === 403) {
                        mobileLog('Premium required error');
                        showSpotifySetupNotification('Spotify Premium is required for this game.', true);
                        reject(new Error(config.ERRORS.NO_PREMIUM));
                    } else {
                        mobileLog('Device check error: ' + error.message);
                        continueInitAfterSpotify = resolve;
                        showSpotifySetupNotification('Unable to connect to Spotify. Please make sure you\'re logged in.');
                        return;
                    }
                }
            });
        }

        function setupEventHandlers() {
            app.input.onLaneHit = (lane, time) => {
                const gameTime = app.timingClock.getTime();
                const result = app.engine.handleLaneHit(lane, gameTime);
                if (result) {
                    app.render.addHitEffect(lane, result.hitType, result.score);
                    if (result.combo > 10) {
                        app.render.addComboPopup(result.combo, result.score);
                    }
                }
            };

            app.engine.onTrackStart = (track, requiredPercent) => {
                mobileLog(`Track started: ${track.name} (${requiredPercent}% required)`);
                app.timingClock.start();
            };

            app.engine.onTrackEnd = (result) => {
                app.ui.showTrackComplete(result);
                app.timingClock.pause();
                
                if (naturalListening.currentTrackIndex === config.NATURAL_LISTENING.SAVE_PROMPT_TRACK - 1 && 
                    naturalListening.shouldShowSavePrompt && 
                    result.currentTrack) {
                    showSavePrompt(result.currentTrack);
                }
            };

            app.engine.onSessionComplete = (result) => {
                app.ui.showResults(result);
                stopGameLoop();
                app.timingClock.reset();
            };

            app.engine.onAdvanceTrack = (trackIndex) => {
                mobileLog(`Game engine requesting advance to track ${trackIndex}`);
                if (trackIndex < app.engine.tracks.length) {
                    if (app.playback && app.playback.advanceTrack) {
                        app.playback.advanceTrack();
                    } else {
                        mobileLog('ERROR: Playback system does not support advanceTrack method');
                    }
                } else {
                    mobileLog('No more tracks to advance to - session should be complete');
                }
            };

            app.playback.onTrackChange = async (track) => {
                try {
                    mobileLog(`Track changed: ${track.name}`);
                    
                    if (!app.engine.midiGenerator.hasMidiData(track.id)) {
                        const error = `No MIDI data available for track: ${track.name} (${track.id}). Game requires MIDI charts to function.`;
                        mobileLog('ERROR: ' + error);
                        showError(error);
                        return;
                    }

                    const trackDuration = track.duration_ms || 180000;
                    const currentTrackIndex = app.engine.currentTrackIndex || 0;
                    initializeNaturalListening(currentTrackIndex, trackDuration);

                    await autoCalibrate();

                    app.timingClock.reset();
                    app.timingClock.start();

                    try {
                        await app.engine.startTrack(track, null);
                        mobileLog('Track started successfully with MIDI chart');
                    } catch (error) {
                        const errorMsg = `Failed to start MIDI track: ${track.name}. ${error.message}`;
                        mobileLog('ERROR: ' + errorMsg);
                        showError(errorMsg);
                        return;
                    }

                } catch (error) {
                    const errorMsg = `Critical error loading track: ${track.name}. ${error.message}`;
                    mobileLog('ERROR: ' + errorMsg);
                    showError(errorMsg);
                }
            };

            app.playback.onStateChange = (state) => {
                if (state.is_playing && app.timingClock.isPaused) {
                    app.timingClock.resume();
                } else if (!state.is_playing && !app.timingClock.isPaused) {
                    app.timingClock.pause();
                }
            };

            app.input.enable();
        }

        function setupDebugMode() {
            let debugMode = false;
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'd') {
                    debugMode = !debugMode;
                    const debugPanel = document.getElementById('timingDebug');
                    debugPanel.style.display = debugMode ? 'block' : 'none';
                }
            });

            setInterval(() => {
                if (debugMode && app.playback && app.timingClock) {
                    const spotifyPos = app.playback.getPositionMs();
                    const clockTime = app.timingClock.getTime();
                    const drift = Math.abs(spotifyPos - clockTime);
                    const autoOffset = app.playback.calibrationOffset || 0;

                    document.getElementById('timingInfo').innerHTML = `
                        Spotify: ${spotifyPos.toFixed(0)}ms<br>
                        Clock: ${clockTime.toFixed(0)}ms<br>
                        Drift: ${drift.toFixed(0)}ms<br>
                        Auto-Offset: ${autoOffset}ms<br>
                        Playing: ${app.playback.getIsPlaying() ? 'Yes' : 'No'}
                    `;
                }
            }, 100);
        }

        async function startGameSession() {
            try {
                mobileLog('Getting user profile...');
                const profile = await app.client.request('/v1/me');
                const country = new URLSearchParams(window.location.search).get('country') || 
                               sessionStorage.getItem('country') || 
                               profile.country || 'US';
                mobileLog(`User: ${profile.display_name}, Country: ${country}`);

                const tracks = await generateTrackList(country);
                mobileLog(`Generated track list: ${tracks.join(', ')}`);
                
                const tracksWithMidi = tracks.filter(trackId => app.engine.midiGenerator.hasMidiData(trackId));
                const tracksWithoutMidi = tracks.filter(trackId => !app.engine.midiGenerator.hasMidiData(trackId));
                
                mobileLog(`Tracks with MIDI: ${tracksWithMidi.length}/${tracks.length}`);
                mobileLog('Available MIDI tracks: ' + tracksWithMidi.join(', '));
                
                if (tracksWithoutMidi.length > 0) {
                    mobileLog('WARNING: Tracks missing MIDI: ' + tracksWithoutMidi.join(', '));
                }
                
                if (tracksWithMidi.length === 0) {
                    throw new Error('No tracks with MIDI data available. Game requires MIDI charts to function.');
                }
                
                const finalTracks = tracksWithMidi;
                mobileLog(`Using ${finalTracks.length} tracks with MIDI data`);

                const playlistNames = generatePlaylistNames(country);
                mobileLog(`Creating playlists: ${playlistNames.public}`);
                
                const [publicPlaylist, privatePlaylist] = await Promise.all([
                    createPlaylist(profile.id, playlistNames.public, true).catch((e) => {
                        mobileLog('Failed to create public playlist: ' + e.message);
                        return null;
                    }),
                    createPlaylist(profile.id, playlistNames.private, false).catch((e) => {
                        mobileLog('Failed to create private playlist: ' + e.message);
                        return null;
                    })
                ]);

                const trackUris = finalTracks.map(id => `spotify:track:${id}`);
                if (publicPlaylist) {
                    addTracksToPlaylist(publicPlaylist.id, trackUris).catch((e) => 
                        mobileLog('Failed to add tracks to public playlist: ' + e.message)
                    );
                }
                if (privatePlaylist) {
                    addTracksToPlaylist(privatePlaylist.id, trackUris).catch((e) => 
                        mobileLog('Failed to add tracks to private playlist: ' + e.message)
                    );
                }

                app.engine.initializeSession(finalTracks, profile.id, generateUUID());

                const playlistToUse = publicPlaylist || privatePlaylist;
                if (playlistToUse) {
                    updateShieldMessage('Starting playlist on your Spotify app...');
                    mobileLog('Starting playback with playlist: ' + playlistToUse.name);
                    await app.playback.startPlayback(playlistToUse.uri, 0);
                    app.playback.lockControls(playlistToUse.uri, finalTracks);
                    mobileLog('Playback started and controls locked');
                } else {
                    throw new Error('Failed to create any playlists');
                }

            } catch (error) {
                mobileLog('FAILED to start game session: ' + error.message);
                console.error('Failed to start game session:', error);
                throw new Error('Failed to start game session: ' + error.message);
            }
        }

        function startGameLoop() {
            let lastTime = performance.now();

            function gameLoop(currentTime) {
                if (!app.isInitialized) return;

                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;

                let spotifyPosition = 0;
                if (app.playback && app.playback.getIsPlaying()) {
                    spotifyPosition = app.playback.getPositionMs();  
                    checkNaturalSkip(spotifyPosition);
                }

                let gameTime = app.timingClock.getTime();
                
                if (spotifyPosition > 0) {
                    const drift = Math.abs(gameTime - spotifyPosition);
                    if (drift > 200) {
                        mobileLog(`Syncing game time: ${gameTime}ms -> ${spotifyPosition}ms (drift: ${drift}ms)`);
                        app.timingClock.reset();
                        app.timingClock.start();
                        app.timingClock.startTime = performance.now() - spotifyPosition;
                        gameTime = spotifyPosition;
                    }
                }

                app.engine.update(deltaTime, gameTime);
                app.input.update();
                app.ui.update(app.engine.getGameState());
                app.render.render(app.engine.getGameState());

                app.gameLoopId = requestAnimationFrame(gameLoop);
            }

            app.gameLoopId = requestAnimationFrame(gameLoop);
        }

        function stopGameLoop() {
            if (app.gameLoopId) {
                cancelAnimationFrame(app.gameLoopId);
                app.gameLoopId = null;
            }
        }

        async function generateTrackList(country) {
            try {
                mobileLog('Using getFinalTrackList() for track generation');
                return getFinalTrackList();
            } catch (error) {
                mobileLog('Failed to get track list, falling back to locked tracks: ' + error.message);
                return config.LOCKED_TRACK_IDS;
            }
        }

        function generatePlaylistNames(country) {
            try {
                return config.generatePlaylistNames ? config.generatePlaylistNames() : {
                    public: 'rhythm game session',
                    private: 'rhythm game session',
                    description: ''
                };
            } catch (error) {
                mobileLog('Failed to generate playlist names: ' + error.message);
                return {
                    public: 'rhythm game session',
                    private: 'rhythm game session',
                    description: ''
                };
            }
        }

        async function createPlaylist(userId, name, isPublic) {
            return await app.client.createPlaylist(userId, {
                name: name,
                public: isPublic
            });
        }

        async function addTracksToPlaylist(playlistId, uris) {
            await app.client.addTracksToPlaylist(playlistId, uris);
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function updateShieldMessage(message) {
            const element = document.getElementById('shieldMessage');
            if (element) {
                element.textContent = message;
            }
        }

        function showError(message) {
            mobileLog('SHOWING ERROR: ' + message);
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorScreen').style.display = 'flex';
        }

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && app.isInitialized && app.timingClock) {
                app.timingClock.pause();
            } else if (!document.hidden && app.isInitialized && app.timingClock && app.playback?.getIsPlaying()) {
                app.timingClock.resume();
            }
        });

        // Handle beforeunload
        window.addEventListener('beforeunload', () => {
            if (app.playback) {
                app.playback.unlockControls();
            }
            if (app.timingClock) {
                app.timingClock.reset();
            }
            stopGameLoop();
        });

        // Initialize the game when page loads
        initGame();
    </script>
</body>
</html>
