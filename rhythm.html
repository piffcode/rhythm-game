<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>RHYTHM - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }
        
        /* Defensive CSS to hide any stray media elements */
        audio, video, iframe, object, embed {
            display: none !important;
            visibility: hidden !important;
        }
        
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }
        
        .input-shield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            touch-action: none;
        }
        
        .shield-content {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            width: 90%;
        }
        
        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin: 10px auto;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #1db954;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            font-size: 16px;
            pointer-events: none;
        }
        
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .score {
            font-weight: bold;
            font-size: 18px;
        }
        
        .combo {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .track-info {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .track-name {
            font-weight: bold;
            font-size: 16px;
        }
        
        .track-artist {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .required-threshold {
            font-size: 12px;
            color: #1db954;
            margin-top: 5px;
        }
        
        .health-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 100%;
        }
        
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 1001;
            animation: fadeInOut 3s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .results-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1db954, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 2000;
        }
        
        .results-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .results-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px;
        }
        
        .track-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        
        .track-result:last-child {
            border-bottom: none;
        }
        
        .track-result-name {
            font-weight: bold;
            font-size: 14px;
            flex: 1;
            text-align: left;
        }
        
        .track-result-score {
            font-size: 12px;
            text-align: right;
            margin-left: 10px;
        }
        
        .completion-code {
            background: rgba(29, 185, 84, 0.2);
            border: 1px solid rgba(29, 185, 84, 0.5);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 2rem;
            text-align: center;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }
        
        .back-link {
            color: #1db954;
            text-decoration: none;
            font-size: 16px;
            margin-top: 1rem;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff4444, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 3000;
            text-align: center;
        }
        
        .error-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        
        .error-message {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            max-width: 400px;
        }

        .timing-debug {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 4px;
            z-index: 200;
            display: none;
        }
    </style>
</head>
<body>
    <!-- Game Canvas -->
    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Game HUD -->
        <div class="hud">
            <div class="hud-top">
                <div class="score" id="scoreDisplay">0</div>
                <div class="combo" id="comboDisplay">0x</div>
            </div>
            <div class="track-info">
                <div class="track-name" id="trackName">Loading...</div>
                <div class="track-artist" id="trackArtist"></div>
                <div class="required-threshold" id="requiredThreshold"></div>
            </div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill"></div>
            </div>
        </div>
        
        <!-- Timing Debug (hidden by default) -->
        <div class="timing-debug" id="timingDebug">
            <div id="timingInfo">Timing Info</div>
        </div>
        
        <!-- Input Shield (shown during loading) -->
        <div class="input-shield" id="inputShield">
            <div class="shield-content">
                <div class="spinner"></div>
                <div style="margin-top: 20px;" id="shieldMessage">Initializing game...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Screen -->
    <div class="results-screen" id="resultsScreen">
        <div class="results-title">Session Complete</div>
        <div class="results-stats" id="resultsStats">
            <!-- Track results will be populated here -->
        </div>
        <div class="completion-code">
            <div style="margin-bottom: 8px; font-weight: bold;">Completion Code:</div>
            <div id="completionCode">RHYTHM-20241217-A1B2C3D4</div>
        </div>
        <a href="/" class="back-link">Play Again</a>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <div class="error-title">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong</div>
        <a href="/" class="back-link">Back to Start</a>
    </div>

    <script type="module">
        import { config, generateCompletionCode } from './config.js';
        import { PKCE } from './auth-pkce.js';
        import { SpotifyClient } from './spotify-client.js';
        import { NativeSpotifyPlayback } from './native-spotify-playback.js';
        import { GameEngine } from './game-engine.js';
        import { GameInput } from './game-input.js';
        import { GameRender } from './game-render.js';
        import { GameUI } from './game-ui.js';
        import { ChartGenerator } from './game-chart.js';

        // Global app state
        let app = {
            auth: null,
            client: null,
            playback: null,
            engine: null,
            input: null,
            render: null,
            ui: null,
            isInitialized: false,
            gameLoopId: null,
            timingClock: null // High precision timing
        };

        // High precision timing clock
        class TimingClock {
            constructor() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
                this.performanceOffset = 0; // Calibration for audio latency
            }

            start() {
                this.startTime = performance.now();
                this.pausedTime = 0;
                this.isPaused = false;
            }

            pause() {
                if (!this.isPaused && this.startTime) {
                    this.isPaused = true;
                    this.pausedTime = performance.now();
                }
            }

            resume() {
                if (this.isPaused && this.pausedTime > 0) {
                    const pauseDuration = performance.now() - this.pausedTime;
                    this.startTime += pauseDuration;
                    this.isPaused = false;
                    this.pausedTime = 0;
                }
            }

            getTime() {
                if (!this.startTime) return 0;
                if (this.isPaused) {
                    return this.pausedTime - this.startTime + this.performanceOffset;
                }
                return performance.now() - this.startTime + this.performanceOffset;
            }

            setCalibration(offsetMs) {
                this.performanceOffset = offsetMs;
            }

            reset() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
            }
        }

        // Progress tracking
        let initProgress = 0;
        const initSteps = 7; // Reduced steps for native playback

        // Update progress display
        function updateProgress(step, message) {
            initProgress = step;
            const percentage = Math.round((step / initSteps) * 100);
            
            updateShieldMessage(message);
            
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
        }

        // Auto-calibration function
        async function autoCalibrate() {
            try {
                // Get tempo information from the current track or MIDI data
                let targetOffset = 0;
                
                if (app.engine && app.engine.currentChart && app.engine.currentChart.metadata.source === 'midi') {
                    // For MIDI tracks, use a small positive offset to account for processing
                    targetOffset = 15; // 15ms ahead to compensate for processing delay
                } else {
                    // For other tracks, use audio analysis or default
                    const track = await app.client.getCurrentPlaybackState();
                    if (track && track.item) {
                        try {
                            const features = await app.client.getAudioFeatures(track.item.id);
                            const tempo = features.tempo || 120;
                            
                            // Calculate offset based on tempo (slower songs need more lookahead)
                            if (tempo < 90) {
                                targetOffset = 25; // Slower songs
                            } else if (tempo > 140) {
                                targetOffset = 10; // Faster songs
                            } else {
                                targetOffset = 15; // Medium tempo
                            }
                        } catch (error) {
                            console.warn('Could not get audio features, using default offset');
                            targetOffset = 15;
                        }
                    }
                }
                
                // Apply the calculated offset
                if (app.playback) {
                    app.playback.setCalibrationOffset(targetOffset);
                    console.log(`Auto-calibration set to ${targetOffset}ms`);
                }
                
            } catch (error) {
                console.warn('Auto-calibration failed:', error);
                // Use default offset
                if (app.playback) {
                    app.playback.setCalibrationOffset(15);
                }
            }
        }

        // Initialize the game
        async function initGame() {
            try {
                updateProgress(0, 'Validating session...');
                
                // Validate bootstrap nonce
                const urlParams = new URLSearchParams(window.location.search);
                const bootstrap = urlParams.get('bootstrap');
                const storedNonce = sessionStorage.getItem('bootstrap_nonce');
                
                if (!bootstrap || bootstrap !== storedNonce) {
                    throw new Error('Invalid session. Please start over.');
                }
                
                sessionStorage.removeItem('bootstrap_nonce');
                
                updateProgress(1, 'Connecting to Spotify...');
                
                // Initialize Spotify client
                app.client = new SpotifyClient();
                await app.client.initialize();
                
                updateProgress(2, 'Checking Premium and finding devices...');
                await checkPremiumStatus();
                
                updateProgress(3, 'Connecting to native Spotify app...');
                // Use native Spotify playback instead of Web Playback SDK
                app.playback = new NativeSpotifyPlayback(app.client);
                await app.playback.initialize();
                
                updateProgress(4, 'Initializing game components...');
                
                // Initialize timing clock
                app.timingClock = new TimingClock();
                
                // Initialize game components in parallel
                const canvas = document.getElementById('gameCanvas');
                
                await Promise.all([
                    new Promise(resolve => {
                        app.engine = new GameEngine();
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.input = new GameInput(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.render = new GameRender(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.ui = new GameUI();
                        resolve();
                    })
                ]);
                
                updateProgress(5, 'Setting up event handlers...');
                setupEventHandlers();
                
                updateProgress(6, 'Preparing game session...');
                await startGameSession();
                
                updateProgress(7, 'Ready!');
                
                // Auto-calibrate based on tempo instead of showing manual calibration
                await autoCalibrate();
                
                // Enable debug mode toggle (press D key)
                setupDebugMode();
                
                // Small delay to show completion
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Hide input shield and start game
                document.getElementById('inputShield').style.display = 'none';
                app.isInitialized = true;
                
                startGameLoop();
                
            } catch (error) {
                console.error('Game initialization failed:', error);
                showError(error.message || 'Failed to initialize game');
            }
        }

        function setupEventHandlers() {
            // Input to engine connection
            app.input.onLaneHit = (lane, time) => {
                const gameTime = app.timingClock.getTime();
                const result = app.engine.handleLaneHit(lane, gameTime);
                if (result) {
                    app.render.addHitEffect(lane, result.hitType, result.score);
                    if (result.combo > 10) {
                        app.render.addComboPopup(result.combo, result.score);
                    }
                }
            };
            
            // Engine event handlers
            app.engine.onTrackStart = (track, requiredPercent) => {
                console.log(`Track started: ${track.name} (${requiredPercent}% required)`);
                app.timingClock.start(); // Start precise timing when track starts
            };
            
            app.engine.onTrackEnd = (result) => {
                app.ui.showTrackComplete(result);
                app.timingClock.pause();
            };
            
            app.engine.onSessionComplete = (result) => {
                app.ui.showResults(result);
                stopGameLoop();
                app.timingClock.reset();
                // Auto-calibration is handled per track, no manual panel needed
            };
            
            // Native playback event handlers
            app.playback.onTrackChange = async (track) => {
                try {
                    console.log(`Track changed: ${track.name}`);
                    
                    // Auto-calibrate for this track
                    await autoCalibrate();
                    
                    // Reset and start timing clock for new track
                    app.timingClock.reset();
                    app.timingClock.start();
                    
                    // Only use MIDI - no audio analysis
                    await app.engine.startTrack(track, null);
                    console.log('Track started successfully with auto-calibration');
                    
                } catch (error) {
                    console.error('Failed to start track:', error);
                    console.log('Trying fallback chart...');
                    const chartGenerator = new ChartGenerator();
                    const fallbackChart = chartGenerator.generateTestChart(track.duration_ms || 30000);
                    console.log('Generated fallback chart with', fallbackChart.notes.length, 'notes');
                    
                    // Check if startTrackWithChart method exists
                    if (app.engine.startTrackWithChart) {
                        await app.engine.startTrackWithChart(track, fallbackChart);
                        console.log('Fallback chart started successfully');
                    } else {
                        console.error('startTrackWithChart method does not exist');
                    }
                }
            };
            
            app.playback.onStateChange = (state) => {
                // Sync timing clock with playback state
                if (state.is_playing && app.timingClock.isPaused) {
                    app.timingClock.resume();
                } else if (!state.is_playing && !app.timingClock.isPaused) {
                    app.timingClock.pause();
                }
            };
            
            // Enable input after initialization
            app.input.enable();
        }

        function setupDebugMode() {
            let debugMode = false;
            
            document.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'd') {
                    debugMode = !debugMode;
                    const debugPanel = document.getElementById('timingDebug');
                    debugPanel.style.display = debugMode ? 'block' : 'none';
                }
            });

            // Update debug info
            setInterval(() => {
                if (debugMode && app.playback && app.timingClock) {
                    const spotifyPos = app.playback.getPositionMs();
                    const clockTime = app.timingClock.getTime();
                    const drift = Math.abs(spotifyPos - clockTime);
                    const autoOffset = app.playback.calibrationOffset || 0;
                    
                    document.getElementById('timingInfo').innerHTML = `
                        Spotify: ${spotifyPos.toFixed(0)}ms<br>
                        Clock: ${clockTime.toFixed(0)}ms<br>
                        Drift: ${drift.toFixed(0)}ms<br>
                        Auto-Offset: ${autoOffset}ms<br>
                        Playing: ${app.playback.getIsPlaying() ? 'Yes' : 'No'}
                    `;
                }
            }, 100);
        }

        async function checkPremiumStatus() {
            try {
                await app.client.request('/v1/me/player/devices');
            } catch (error) {
                if (error.status === 403) {
                    throw new Error(config.ERRORS.NO_PREMIUM);
                }
            }
        }

        async function startGameSession() {
            try {
                // Get user profile
                const profile = await app.client.request('/v1/me');
                const country = new URLSearchParams(window.location.search).get('country') || 
                               sessionStorage.getItem('country') || 
                               profile.country || 'US';
                
                // Generate track list
                const tracks = await generateTrackList(country);
                
                // Create playlists in parallel
                const playlistNames = generatePlaylistNames(country);
                const [publicPlaylist, privatePlaylist] = await Promise.all([
                    createPlaylist(profile.id, playlistNames.public, true).catch(() => null),
                    createPlaylist(profile.id, playlistNames.private, false).catch(() => null)
                ]);
                
                // Add tracks to playlists (non-blocking)
                const trackUris = tracks.map(id => `spotify:track:${id}`);
                if (publicPlaylist) {
                    addTracksToPlaylist(publicPlaylist.id, trackUris).catch(console.warn);
                }
                if (privatePlaylist) {
                    addTracksToPlaylist(privatePlaylist.id, trackUris).catch(console.warn);
                }
                
                // Initialize game session
                app.engine.initializeSession(tracks, profile.id, generateUUID());
                
                // Start playlist on user's native Spotify app
                const playlistToUse = publicPlaylist || privatePlaylist;
                if (playlistToUse) {
                    updateShieldMessage('Starting playlist on your Spotify app...');
                    await app.playback.startPlayback(playlistToUse.uri, 0);
                    app.playback.lockControls(playlistToUse.uri, tracks);
                } else {
                    throw new Error('Failed to create any playlists');
                }
                
            } catch (error) {
                console.error('Failed to start game session:', error);
                throw new Error('Failed to start game session: ' + error.message);
            }
        }

        function startGameLoop() {
            let lastTime = performance.now();
            
            function gameLoop(currentTime) {
                if (!app.isInitialized) return;
                
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                
                // Use our high-precision timing clock instead of Spotify position
                const gameTime = app.timingClock.getTime();
                
                // Update game components
                app.engine.update(deltaTime, gameTime);
                app.input.update();
                app.ui.update(app.engine.getGameState());
                
                // Render frame
                app.render.render(app.engine.getGameState());
                
                // Continue loop
                app.gameLoopId = requestAnimationFrame(gameLoop);
            }
            
            app.gameLoopId = requestAnimationFrame(gameLoop);
        }

        function stopGameLoop() {
            if (app.gameLoopId) {
                cancelAnimationFrame(app.gameLoopId);
                app.gameLoopId = null;
            }
        }

        async function generateTrackList(country) {
            const lockedTracks = config.LOCKED_TRACK_IDS;
            
            try {
                const fallback = await app.client.getRecommendations({
                    seed_genres: 'pop,dance',
                    market: country,
                    limit: 1
                });
                
                if (fallback.tracks && fallback.tracks.length > 0) {
                    return [...lockedTracks, fallback.tracks[0].id];
                }
            } catch (error) {
                console.warn('Recommendations failed:', error);
            }
            
            return [...lockedTracks, lockedTracks[0]];
        }

        function generatePlaylistNames(country) {
            const adjectives = ['Epic', 'Ultimate', 'Perfect'];
            const nouns = ['Rhythm', 'Beat', 'Vibe'];
            const nonce = Math.random().toString(36).substring(2, 6).toUpperCase();
            
            const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            
            return {
                public: `RHYTHM — ${country} — ${adjective} ${noun} #${nonce}`,
                private: `RHYTHM — ${country} — ${adjective} ${noun} #${nonce}`
            };
        }

        async function createPlaylist(userId, name, isPublic) {
            return await app.client.createPlaylist(userId, {
                name: name,
                description: `Rhythm game session - ${new Date().toISOString()}`,
                public: isPublic
            });
        }

        async function addTracksToPlaylist(playlistId, uris) {
            await app.client.addTracksToPlaylist(playlistId, uris);
        }

        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function updateShieldMessage(message) {
            const element = document.getElementById('shieldMessage');
            if (element) {
                element.textContent = message;
            }
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorScreen').style.display = 'flex';
        }

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && app.isInitialized && app.timingClock) {
                app.timingClock.pause();
            } else if (!document.hidden && app.isInitialized && app.timingClock && app.playback?.getIsPlaying()) {
                app.timingClock.resume();
            }
        });

        // Handle beforeunload
        window.addEventListener('beforeunload', () => {
            if (app.playback) {
                app.playback.unlockControls();
            }
            if (app.timingClock) {
                app.timingClock.reset();
            }
            stopGameLoop();
        });

        // Initialize the game when page loads
        initGame();
    </script>
</body>
</html>
