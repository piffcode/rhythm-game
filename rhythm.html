<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>RHYTHM - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            overscroll-behavior: none;
        }

        /* Defensive CSS to hide any stray media elements */
        audio, video, iframe, object, embed {
            display: none !important;
            visibility: hidden !important;
        }

        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        .input-shield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            touch-action: none;
        }

        .shield-content {
            text-align: center;
            padding: 20px;
            max-width: 400px;
            width: 90%;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin: 10px auto;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #1db954;
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .loading-step {
            width: 100%;
            max-width: 450px;
        }

        .step-content {
            text-align: center;
        }

        .step-content.hidden {
            display: none;
        }

        .step-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.9;
        }

        .step-title {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #1db954;
        }

        .step-description {
            font-size: 1rem;
            margin-bottom: 1.5rem;
            opacity: 0.9;
            line-height: 1.4;
        }

        .step-instructions {
            text-align: left;
            max-width: 350px;
            margin: 0 auto 1.5rem;
            padding-left: 1rem;
        }

        .step-instructions li {
            margin-bottom: 0.8rem;
            font-size: 0.95rem;
            line-height: 1.4;
            opacity: 0.9;
        }

        .step-note {
            font-size: 0.85rem;
            opacity: 0.7;
            margin-bottom: 2rem;
            font-style: italic;
            color: #cccccc;
        }

        .auto-start-indicator {
            background: rgba(29, 185, 84, 0.1);
            border: 1px solid rgba(29, 185, 84, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 1rem 0;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            background: #1db954;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .step-message {
            font-size: 1.1rem;
            margin: 1rem 0;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .step-icon {
                font-size: 3rem;
            }
            
            .step-title {
                font-size: 1.5rem;
            }
            
            .step-instructions {
                padding-left: 0.5rem;
                max-width: 300px;
            }
            
            .step-instructions li {
                font-size: 0.9rem;
            }
        }

        .hud {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            font-size: 16px;
            pointer-events: none;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .score {
            font-weight: bold;
            font-size: 18px;
        }

        .combo {
            font-size: 14px;
            opacity: 0.8;
        }

        .track-info {
            text-align: center;
            margin-bottom: 10px;
        }

        .track-name {
            font-weight: bold;
            font-size: 16px;
        }

        .track-artist {
            font-size: 14px;
            opacity: 0.8;
        }

        .required-threshold {
            font-size: 12px;
            color: #1db954;
            margin-top: 5px;
        }

        .health-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            border-radius: 2px;
            transition: width 0.3s ease;
            width: 100%;
        }

        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 1001;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
            10%, 90% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .results-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1db954, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 2000;
        }

        .results-title {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 2rem;
            text-align: center;
        }

        .results-stats {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 2rem;
            width: 100%;
            max-width: 400px;
        }

        .track-result {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .track-result:last-child {
            border-bottom: none;
        }

        .track-result-name {
            font-weight: bold;
            font-size: 14px;
            flex: 1;
            text-align: left;
        }

        .track-result-score {
            font-size: 12px;
            text-align: right;
            margin-left: 10px;
        }

        .completion-code {
            background: rgba(29, 185, 84, 0.2);
            border: 1px solid rgba(29, 185, 84, 0.5);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 2rem;
            text-align: center;
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
        }

        .back-link {
            color: #1db954;
            text-decoration: none;
            font-size: 16px;
            margin-top: 1rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .error-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ff4444, #191414);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 3000;
            text-align: center;
        }

        .error-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }

        .error-message {
            font-size: 1.2rem;
            margin-bottom: 2rem;
            opacity: 0.9;
            max-width: 400px;
        }

        .timing-debug {
            position: fixed;
            top: 120px;
            right: 20px;
            background: rgba(0,0,0,0.75);
            color: white;
            padding: 12px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 6px;
            z-index: 200;
            display: none;
            width: 280px;
            max-height: 60vh;
            overflow: hidden;
            box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
        }

        .timing-debug .debug-section {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
        }

        .timing-debug .debug-section:first-child {
            margin-top: 0;
            padding-top: 0;
            border-top: none;
        }

        .debug-section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            opacity: 0.75;
            margin-bottom: 4px;
        }

        .debug-events {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .debug-event {
            display: flex;
            gap: 6px;
            font-size: 11px;
            line-height: 1.4;
        }

        .debug-event-time {
            color: rgba(255, 255, 255, 0.55);
            flex-shrink: 0;
        }

        .debug-event-name {
            color: #1db954;
            flex-shrink: 0;
        }

        .debug-event-payload {
            color: rgba(255, 255, 255, 0.85);
            flex: 1;
            word-break: break-word;
        }
    </style>
</head>
<body>
    <!-- Game Canvas -->
    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>

        <!-- Game HUD -->
        <div class="hud">
            <div class="hud-top">
                <div class="score" id="scoreDisplay">0</div>
                <div class="combo" id="comboDisplay">0x</div>
            </div>
            <div class="track-info">
                <div class="track-name" id="trackName">Loading...</div>
                <div class="track-artist" id="trackArtist"></div>
                <div class="required-threshold" id="requiredThreshold"></div>
            </div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill"></div>
            </div>
        </div>

        <!-- Timing Debug (hidden by default) -->
        <div class="timing-debug" id="timingDebug">
            <div class="debug-section">
                <div class="debug-section-title">Metrics</div>
                <div id="timingInfo">Timing Info</div>
            </div>
            <div class="debug-section">
                <div class="debug-section-title">Recent Events</div>
                <div class="debug-events" id="debugEvents"></div>
            </div>
        </div>

        <!-- Auto-Detection Input Shield -->
        <div class="input-shield" id="inputShield">
            <div class="shield-content">
                <div class="loading-step" id="loadingStep">
                    <!-- Step 1: Spotify Auto-Detection -->
                    <div class="step-content" id="spotifySetup">
                        <div class="step-icon">üéµ</div>
                        <h2 class="step-title" id="spotifyTitle">Checking for Spotify...</h2>
                        <div class="auto-start-indicator" id="autoStartIndicator">
                            <div class="pulse-dot"></div>
                            <span id="detectionStatus">Looking for active Spotify session...</span>
                        </div>
                        <div class="step-description" id="spotifyInstructions" style="display: none;">
                            To play this rhythm game, please:
                            <ol class="step-instructions">
                                <li>Open your Spotify app (phone, computer, or web)</li>
                                <li>Start playing any song to activate your device</li>
                                <li>Return to this page - the game will start automatically</li>
                            </ol>
                        </div>
                        <div class="step-note">
                            The game will start automatically when an active Spotify session is detected
                        </div>
                    </div>
                    
                    <!-- Step 2: Loading Game -->
                    <div class="step-content hidden" id="gameLoading">
                        <div class="spinner"></div>
                        <div class="step-message" id="shieldMessage">Initializing game...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="step-note" id="loadingNote">
                            Setting up your rhythm game experience...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Screen -->
    <div class="results-screen" id="resultsScreen">
        <div class="results-title">Session Complete</div>
        <div class="results-stats" id="resultsStats">
            <!-- Track results will be populated here -->
        </div>
        <div class="completion-code">
            <div style="margin-bottom: 8px; font-weight: bold;">Completion Code:</div>
            <div id="completionCode">RHYTHM-20241217-A1B2C3D4</div>
        </div>
        <a href="/" class="back-link">Play Again</a>
    </div>

    <!-- Error Screen -->
    <div class="error-screen" id="errorScreen">
        <div class="error-title">Error</div>
        <div class="error-message" id="errorMessage">Something went wrong</div>
        <a href="/" class="back-link">Back to Start</a>
    </div>

    <script type="module">
        import { config, generateCompletionCode } from './config.js';
        import { SpotifyClient } from './spotify-client.js';
        import { NativeSpotifyPlayback } from './native-spotify-playback.js';
        import { GameEngine } from './game-engine.js';
        import { GameInput } from './game-input.js';
        import { GameRender } from './game-render.js';
        import { GameUI } from './game-ui.js';
        import { GameDebugger } from './game-debug.js';

        // Global app state
        let app = {
            auth: null,
            client: null,
            playback: null,
            engine: null,
            input: null,
            render: null,
            ui: null,
            isInitialized: false,
            gameLoopId: null,
            timingClock: null,
            debugger: null,
            spotifyDetectionInterval: null,
            pageLoadTime: Date.now(),
            playbackBindingsConfigured: false
        };

        app.debugger = new GameDebugger({
            maxEvents: 120,
            pollInterval: 200,
            consoleMirror: false
        });
        app.debugger.setExtraMetrics({ 'Session Status': 'Starting' });

        // Auto-detection state
        let autoStartState = {
            isDetecting: false,
            detectionAttempts: 0,
            detectionInterval: 3000, // Check every 3 seconds
            hasDetectedSpotify: false,
            showedInstructions: false
        };

        // Natural listening behavior state
        let naturalListening = {
            skipThreshold: Infinity,
            shouldShowSavePrompt: false,
            savePromptShown: false,
            savePromptDelay: 0,
            currentTrackIndex: -1,
            trackStartTime: 0
        };

        // Start continuous Spotify detection
        function startSpotifyAutoDetection() {
            if (autoStartState.isDetecting || autoStartState.hasDetectedSpotify) {
                return;
            }

            autoStartState.isDetecting = true;
            const indicator = document.getElementById('autoStartIndicator');
            const instructions = document.getElementById('spotifyInstructions');
            const title = document.getElementById('spotifyTitle');
            const detectionStatus = document.getElementById('detectionStatus');

            console.log('Starting continuous Spotify detection...');
            app.debugger?.log('autostart:detectionStarted');

            app.spotifyDetectionInterval = setInterval(async () => {
                if (autoStartState.hasDetectedSpotify) {
                    clearInterval(app.spotifyDetectionInterval);
                    return;
                }

                autoStartState.detectionAttempts++;
                
                try {
                    // Initialize client if needed
                    if (!app.client) {
                        app.client = new SpotifyClient();
                        await app.client.initialize();
                    }

                    // Check for active playback
                    const playbackState = await app.client.getPlaybackState();
                    
                    if (playbackState && playbackState.is_playing && playbackState.device) {
                        console.log('Active Spotify session detected!', {
                            device: playbackState.device.name,
                            track: playbackState.item?.name
                        });
                        
                        app.debugger?.log('autostart:spotifyDetected', {
                            deviceName: playbackState.device.name,
                            trackName: playbackState.item?.name,
                            attempts: autoStartState.detectionAttempts
                        });

                        // Mark as detected and stop detection
                        autoStartState.hasDetectedSpotify = true;
                        clearInterval(app.spotifyDetectionInterval);

                        // Update UI to show success
                        if (title) {
                            title.textContent = 'Spotify Connected!';
                        }

                        if (detectionStatus) {
                            detectionStatus.textContent = 'Starting rhythm game...';
                        }

                        if (indicator) {
                            const dot = indicator.querySelector('.pulse-dot');
                            if (dot) {
                                dot.style.background = '#1db954';
                                dot.style.animation = 'none';
                            }
                        }

                        // Auto-start the game
                        setTimeout(() => {
                            startGame();
                        }, 1500);

                        return;
                    }

                    // Show instructions after a few failed attempts
                    if (autoStartState.detectionAttempts >= 2 && !autoStartState.showedInstructions) {
                        autoStartState.showedInstructions = true;
                        if (title) {
                            title.textContent = 'Spotify Not Active';
                        }
                        if (instructions) {
                            instructions.style.display = 'block';
                        }
                        if (detectionStatus) {
                            detectionStatus.textContent = 'Waiting for Spotify to start playing...';
                        }
                    }

                    // Update status periodically
                    const minutes = Math.floor(autoStartState.detectionAttempts * autoStartState.detectionInterval / 60000);
                    if (minutes > 0 && detectionStatus && autoStartState.showedInstructions) {
                        detectionStatus.textContent = `Still waiting for Spotify... (${minutes}m)`;
                    }

                } catch (error) {
                    console.log('Detection attempt failed:', error.message);
                    app.debugger?.log('autostart:detectionError', {
                        attempt: autoStartState.detectionAttempts,
                        message: error.message
                    });

                    // Show instructions on error after first few attempts
                    if (autoStartState.detectionAttempts >= 3 && !autoStartState.showedInstructions) {
                        autoStartState.showedInstructions = true;
                        const title = document.getElementById('spotifyTitle');
                        const instructions = document.getElementById('spotifyInstructions');
                        const detectionStatus = document.getElementById('detectionStatus');
                        
                        if (title) {
                            title.textContent = 'Spotify Required';
                        }
                        if (instructions) {
                            instructions.style.display = 'block';
                        }
                        if (detectionStatus) {
                            detectionStatus.textContent = 'Please start Spotify and play a song...';
                        }
                    }
                }

            }, autoStartState.detectionInterval);
        }

        // Start the game (no manual intervention)
        function startGame() {
            // Log the start
            app.debugger?.log('game:autoStart', {
                detectionAttempts: autoStartState.detectionAttempts
            });

            // Hide Spotify setup step
            document.getElementById('spotifySetup').classList.add('hidden');
            
            // Show loading step
            document.getElementById('gameLoading').classList.remove('hidden');
            
            // Start the actual game initialization
            setTimeout(() => {
                initGame();
            }, 500);
        }

        // Initialize natural listening for a track
        function initializeNaturalListening(trackIndex, trackDuration) {
            const minPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MIN;
            const maxPercent = config.NATURAL_LISTENING.SKIP_THRESHOLD_MAX;
            const skipPercent = minPercent + Math.random() * (maxPercent - minPercent);

            if (!Number.isFinite(trackDuration) || trackDuration <= 0) {
                naturalListening.skipThreshold = Infinity;
            } else {
                naturalListening.skipThreshold = (skipPercent / 100) * trackDuration;
            }
            naturalListening.currentTrackIndex = trackIndex;
            naturalListening.trackStartTime = Date.now();
            naturalListening.savePromptShown = false;

            if (trackIndex === config.NATURAL_LISTENING.SAVE_PROMPT_TRACK - 1) {
                naturalListening.shouldShowSavePrompt = Math.random() < config.NATURAL_LISTENING.SAVE_PROMPT_PROBABILITY;
                if (naturalListening.shouldShowSavePrompt) {
                    const minDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MIN;
                    const maxDelay = config.NATURAL_LISTENING.SAVE_PROMPT_DELAY_MAX;
                    naturalListening.savePromptDelay = minDelay + Math.random() * (maxDelay - minDelay);
                    app.debugger?.log('natural:savePromptScheduled', {
                        trackIndex,
                        delayMs: Math.round(naturalListening.savePromptDelay)
                    });
                }
            } else {
                naturalListening.shouldShowSavePrompt = false;
            }

            app.debugger?.log('natural:configure', {
                trackIndex,
                skipPercent: Number(skipPercent.toFixed(1)),
                skipThreshold: Math.round(naturalListening.skipThreshold),
                savePromptPlanned: naturalListening.shouldShowSavePrompt
            });
        }

        // Check if we should skip to next track
        function checkNaturalSkip(currentPosition) {
            // Only trigger when the threshold has been configured for the active track
            if (app.engine &&
                naturalListening.currentTrackIndex === app.engine.currentTrackIndex &&
                Number.isFinite(naturalListening.skipThreshold) &&
                naturalListening.skipThreshold > 0 &&
                currentPosition >= naturalListening.skipThreshold) {
                app.debugger?.log('natural:skipTrigger', {
                    position: Math.round(currentPosition),
                    threshold: Math.round(naturalListening.skipThreshold)
                });
                if (app.playback && app.playback.advanceTrack) {
                    app.playback.advanceTrack().catch(error => {
                        app.debugger?.log('playback:advanceError', { message: error.message });
                    });
                }
                return true;
            }
            return false;
        }

        // Bind native Spotify playback events to the game engine
        function bindPlaybackToEngine() {
            if (!app.playback || !app.engine || !app.client) {
                return;
            }

            if (app.playbackBindingsConfigured) {
                return;
            }
            app.playbackBindingsConfigured = true;

            const handleTrackChange = async (track) => {
                if (!track || !track.id) {
                    app.debugger?.log('playback:trackChangeIgnored', { reason: 'invalidTrack' });
                    return;
                }

                try {
                    const trackIndex = Array.isArray(app.engine.tracks)
                        ? app.engine.tracks.findIndex(sessionTrack => sessionTrack?.id === track.id)
                        : -1;

                    if (trackIndex >= 0) {
                        app.engine.currentTrackIndex = trackIndex;
                    }

                    app.debugger?.log('playback:trackChange', {
                        trackId: track.id,
                        trackName: track.name,
                        trackIndex
                    });

                    let audioAnalysis = null;
                    if (!app.engine.midiGenerator.hasMidiData(track.id)) {
                        try {
                            audioAnalysis = await app.client.getAudioAnalysis(track.id);
                            app.debugger?.log('playback:analysisLoaded', {
                                trackId: track.id
                            });
                        } catch (analysisError) {
                            console.warn('Audio analysis unavailable, using procedural chart:', analysisError);
                            app.debugger?.log('playback:analysisError', {
                                trackId: track.id,
                                message: analysisError.message
                            });
                        }
                    }

                    await app.engine.startTrack(track, audioAnalysis);
                    app.debugger?.setExtraMetrics({
                        'Now Playing': `${track.name} ‚Äì ${track.artists?.[0]?.name || 'Unknown Artist'}`
                    });
                } catch (error) {
                    console.error('Failed to start track from native playback:', error);
                    app.debugger?.log('playback:startTrackError', {
                        message: error.message
                    });
                }
            };

            app.playback.onTrackChange = handleTrackChange;

            app.playback.onStateChange = (state) => {
                if (!state) {
                    return;
                }

                if (!state.is_playing && app.engine?.isPlaying) {
                    app.engine.pause?.();
                } else if (state.is_playing && app.engine?.isPaused) {
                    app.engine.resume?.();
                }

                app.debugger?.setExtraMetrics({
                    'Playback State': state.is_playing ? 'Playing' : 'Paused'
                });
            };

            const hydrateInitialTrack = async () => {
                try {
                    const initialTrack = typeof app.playback.getCurrentTrack === 'function'
                        ? app.playback.getCurrentTrack()
                        : app.playback.currentTrack;

                    if (initialTrack) {
                        await handleTrackChange(initialTrack);
                        return;
                    }

                    const playbackState = await app.client.getPlaybackState();
                    if (playbackState?.item) {
                        await handleTrackChange(playbackState.item);
                    }
                } catch (error) {
                    console.warn('Unable to hydrate initial native playback state:', error);
                    app.debugger?.log('playback:initialStateError', { message: error.message });
                }
            };

            hydrateInitialTrack();
        }

        // Show save prompt after track ends
        function showSavePrompt(track) {
            if (!naturalListening.shouldShowSavePrompt || naturalListening.savePromptShown) {
                return;
            }
            
            naturalListening.savePromptShown = true;
            
            setTimeout(async () => {
                try {
                    const savePrompt = document.createElement('div');
                    savePrompt.style.cssText = `
                        position: fixed;
                        bottom: 120px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(30, 30, 30, 0.95);
                        backdrop-filter: blur(10px);
                        color: white;
                        padding: 16px 20px;
                        border-radius: 25px;
                        font-size: 14px;
                        z-index: 1001;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        border: 1px solid rgba(255,255,255,0.1);
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        max-width: 90%;
                        animation: slideUpFade 0.3s ease-out;
                    `;
                    
                    if (!document.querySelector('#savePromptStyle')) {
                        const style = document.createElement('style');
                        style.id = 'savePromptStyle';
                        style.textContent = `
                            @keyframes slideUpFade {
                                0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                                100% { opacity: 1; transform: translateX(-50%) translateY(0); }
                            }
                            @keyframes slideDownFade {
                                0% { opacity: 1; transform: translateX(-50%) translateY(0); }
                                100% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    const heartIcon = document.createElement('div');
                    heartIcon.innerHTML = 'ü§ç';
                    heartIcon.style.fontSize = '18px';
                    
                    const trackInfo = document.createElement('div');
                    trackInfo.innerHTML = `
                        <div style="font-weight: 500; margin-bottom: 2px;">${track.name}</div>
                        <div style="font-size: 12px; opacity: 0.7;">${track.artists?.[0]?.name || 'Unknown Artist'}</div>
                    `;
                    
                    const saveButton = document.createElement('button');
                    saveButton.textContent = 'Save';
                    saveButton.style.cssText = `
                        background: #1db954;
                        color: white;
                        border: none;
                        padding: 8px 16px;
                        border-radius: 20px;
                        font-size: 12px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    `;
                    
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '√ó';
                    closeButton.style.cssText = `
                        background: none;
                        color: rgba(255,255,255,0.7);
                        border: none;
                        font-size: 18px;
                        cursor: pointer;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: 8px;
                    `;
                    
                    savePrompt.appendChild(heartIcon);
                    savePrompt.appendChild(trackInfo);
                    savePrompt.appendChild(saveButton);
                    savePrompt.appendChild(closeButton);
                    document.body.appendChild(savePrompt);
                    
                    app.debugger?.log('natural:savePromptShown', {
                        trackId: track.id,
                        trackName: track.name
                    });
                    
                    // Button interactions
                    saveButton.addEventListener('mouseenter', () => {
                        saveButton.style.background = '#1ed760';
                        saveButton.style.transform = 'scale(1.05)';
                    });
                    
                    saveButton.addEventListener('mouseleave', () => {
                        saveButton.style.background = '#1db954';
                        saveButton.style.transform = 'scale(1)';
                    });
                    
                    // Save functionality
                    saveButton.addEventListener('click', async () => {
                        try {
                            app.debugger?.log('natural:savePromptAccepted', {
                                trackId: track.id,
                                trackName: track.name
                            });
                            await app.client.saveTrack(track.id);

                            heartIcon.innerHTML = 'üíö';
                            saveButton.textContent = 'Saved!';
                            saveButton.style.background = '#1ed760';
                            saveButton.disabled = true;

                            app.debugger?.log('natural:savePromptSaved', {
                                trackId: track.id
                            });

                            setTimeout(() => {
                                if (savePrompt.parentNode) {
                                    savePrompt.style.animation = 'slideDownFade 0.3s ease-out';
                                    setTimeout(() => {
                                        if (savePrompt.parentNode) {
                                            savePrompt.parentNode.removeChild(savePrompt);
                                        }
                                    }, 300);
                                }
                            }, 2000);
                            
                        } catch (error) {
                            console.error('Failed to save track:', error);
                            saveButton.textContent = 'Error';
                            saveButton.style.background = '#ff4444';
                            app.debugger?.log('natural:savePromptError', {
                                trackId: track.id,
                                message: error.message
                            });
                        }
                    });
                    
                    // Close functionality
                    const closeSavePrompt = () => {
                        if (savePrompt.parentNode) {
                            savePrompt.style.animation = 'slideDownFade 0.3s ease-out';
                            setTimeout(() => {
                                if (savePrompt.parentNode) {
                                    savePrompt.parentNode.removeChild(savePrompt);
                                }
                            }, 300);
                        }
                    };
                    
                    closeButton.addEventListener('click', closeSavePrompt);
                    setTimeout(closeSavePrompt, 8000);
                    
                } catch (error) {
                    console.error('Failed to show save prompt:', error);
                    app.debugger?.log('natural:savePromptFailure', {
                        trackId: track.id,
                        message: error.message
                    });
                }
            }, naturalListening.savePromptDelay);
        }

        // High precision timing clock
        class TimingClock {
            constructor() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
                this.performanceOffset = 0;
            }

            start() {
                this.startTime = performance.now();
                this.pausedTime = 0;
                this.isPaused = false;
            }

            pause() {
                if (!this.isPaused && this.startTime) {
                    this.isPaused = true;
                    this.pausedTime = performance.now();
                }
            }

            resume() {
                if (this.isPaused && this.pausedTime > 0) {
                    const pauseDuration = performance.now() - this.pausedTime;
                    this.startTime += pauseDuration;
                    this.isPaused = false;
                    this.pausedTime = 0;
                }
            }

            getTime() {
                if (!this.startTime) return 0;
                if (this.isPaused) {
                    return this.pausedTime - this.startTime + this.performanceOffset;
                }
                return performance.now() - this.startTime + this.performanceOffset;
            }

            setCalibration(offsetMs) {
                this.performanceOffset = offsetMs;
            }

            reset() {
                this.startTime = null;
                this.pausedTime = 0;
                this.isPaused = false;
            }
        }

        // Progress tracking
        let initProgress = 0;
        const initSteps = 7;

        // Update progress display
        function updateProgress(step, message) {
            initProgress = step;
            const percentage = Math.round((step / initSteps) * 100);
            updateShieldMessage(message);
            app.debugger?.log('init:progress', { step, message, percentage });
            app.debugger?.setExtraMetrics({ 'Initialization': `${percentage}% - ${message}` });
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }
        }

        // Enhanced updateShieldMessage function
        function updateShieldMessage(message) {
            const element = document.getElementById('shieldMessage');
            const noteElement = document.getElementById('loadingNote');
            
            if (element) {
                element.textContent = message;
            }
            
            if (noteElement) {
                switch (message) {
                    case 'Connecting to Spotify...':
                        noteElement.textContent = 'Establishing connection with your Spotify account...';
                        break;
                    case 'Checking Premium and finding devices...':
                        noteElement.textContent = 'Looking for your active Spotify device...';
                        break;
                    case 'Connecting to native Spotify app...':
                        noteElement.textContent = 'Connecting to your Spotify app for music playback...';
                        break;
                    case 'Initializing game components...':
                        noteElement.textContent = 'Setting up the rhythm game engine...';
                        break;
                    case 'Setting up event handlers...':
                        noteElement.textContent = 'Configuring game controls and interactions...';
                        break;
                    case 'Preparing game session...':
                        noteElement.textContent = 'Creating your personalized playlist and charts...';
                        break;
                    case 'Ready!':
                        noteElement.textContent = 'Everything is ready! Starting your rhythm game...';
                        break;
                    default:
                        noteElement.textContent = 'Setting up your rhythm game experience...';
                }
            }
            
            app.debugger?.log('ui:shieldMessage', { message });
        }

        // Auto-calibration function
        async function autoCalibrate() {
            try {
                let targetOffset = 0;
                if (app.engine && app.engine.currentChart && app.engine.currentChart.metadata.source === 'midi') {
                    targetOffset = 15;
                } else {
                    const playbackState = await app.client.getPlaybackState();
                    if (playbackState && playbackState.item) {
                        try {
                            const features = await app.client.getAudioFeatures(playbackState.item.id);
                            const feature = Array.isArray(features?.audio_features)
                                ? features.audio_features[0]
                                : features;
                            const tempo = feature?.tempo || 120;
                            
                            if (tempo < 90) {
                                targetOffset = 25;
                            } else if (tempo > 140) {
                                targetOffset = 10;
                            } else {
                                targetOffset = 15;
                            }
                        } catch (error) {
                            console.warn('Could not get audio features, using default offset');
                            targetOffset = 15;
                        }
                    }
                }

                if (app.playback) {
                    app.playback.setCalibrationOffset(targetOffset);
                    console.log(`Auto-calibration set to ${targetOffset}ms`);
                    app.debugger?.log('calibration:applied', {
                        offset: targetOffset,
                        strategy: app.engine?.currentChart?.metadata?.source === 'midi' ? 'midi-default' : 'tempo-analysis'
                    });
                    app.debugger?.setExtraMetrics({ 'Calibration Offset': `${targetOffset}ms` });
                }
            } catch (error) {
                console.warn('Auto-calibration failed:', error);
                if (app.playback) {
                    app.playback.setCalibrationOffset(15);
                }
                app.debugger?.log('calibration:error', {
                    message: error.message
                });
                app.debugger?.setExtraMetrics({ 'Calibration Offset': '15ms (fallback)' });
            }
        }

        // Check premium status
        async function checkPremiumStatus() {
            const userProfile = await app.client.getCurrentUser();
            if (userProfile.product !== 'premium') {
                throw new Error(config.ERRORS.NO_PREMIUM);
            }
            return userProfile;
        }

        // Setup event handlers
        function setupEventHandlers() {
            if (app.input && app.engine) {
                app.input.onLaneHit = (lane, inputTime) => {
                    const timingAdjustedInput = Number.isFinite(inputTime)
                        ? app.engine.getCurrentGameTime()
                        : undefined;
                    const result = app.engine.handleLaneHit(lane, timingAdjustedInput);
                    if (result && app.render) {
                        app.render.showHitEffect(lane, result.hitType, result);
                    }
                };

                app.input.setLanes(config.DIFFICULTY_SETTINGS[app.engine.difficulty].lanes);
                app.input.enable();
            }

            if (app.engine) {
                app.engine.onTrackStart = (track, requiredPercent) => {
                    initializeNaturalListening(app.engine.currentTrackIndex, track.duration_ms);
                    if (app.ui) {
                        app.ui.updateTrackInfo(track.name, track.artists?.[0]?.name || 'Unknown', requiredPercent);
                    }
                };

                app.engine.onTrackEnd = (trackResult) => {
                    if (app.ui) {
                        app.ui.showTrackComplete(trackResult);
                    }
                    
                    if (trackResult.trackIndex === 1 && naturalListening.shouldShowSavePrompt) {
                        showSavePrompt(app.engine.currentTrack);
                    }
                };

                app.engine.onSessionComplete = (sessionResult) => {
                    if (app.ui) {
                        app.ui.showResults(sessionResult);
                    }
                    app.isInitialized = false;
                    app.playbackBindingsConfigured = false;
                    if (app.gameLoopId) {
                        cancelAnimationFrame(app.gameLoopId);
                        app.gameLoopId = null;
                    }
                };

                app.engine.onAdvanceTrack = async (trackIndex) => {
                    if (app.playback && trackIndex < app.engine.tracks.length) {
                        try {
                            await app.playback.advanceTrack();
                        } catch (error) {
                            console.error('Failed to advance track:', error);
                        }
                    }
                };
            }
        }

        // Start game session
        async function startGameSession() {
            const sessionId = Math.random().toString(36).substring(2, 15);
            const userProfile = await app.client.getCurrentUser();
            
            const playlistData = await app.playback.setupGameSession();
            
            app.engine.initializeSession(playlistData.tracks, userProfile.id, sessionId);
            
            if (app.render) {
                app.render.setLanes(config.DIFFICULTY_SETTINGS[app.engine.difficulty].lanes);
            }
            
            console.log('Game session started:', {
                sessionId,
                tracks: playlistData.tracks.length,
                playlistId: playlistData.playlistId
            });
        }

        // Start game loop
        function startGameLoop() {
            let lastTime = performance.now();
            
            function gameLoop(currentTime) {
                if (!app.isInitialized) return;
                
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                
                // Update game engine
                if (app.engine && app.playback) {
                    const audioPosition = app.playback.getPositionMs();
                    app.engine.update(deltaTime, audioPosition);
                    
                    // Check for natural skip
                    if (audioPosition > 0) {
                        checkNaturalSkip(audioPosition);
                    }
                }
                
                // Update input
                if (app.input) {
                    app.input.update();
                }
                
                // Update UI
                if (app.ui && app.engine) {
                    app.ui.update(app.engine.getGameState());
                }
                
                // Render game
                if (app.render && app.engine) {
                    app.render.render(app.engine.getGameState());
                }
                
                app.gameLoopId = requestAnimationFrame(gameLoop);
            }
            
            app.gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Setup debug mode
        function setupDebugMode() {
            document.addEventListener('keydown', (event) => {
                if (event.key === 'd' || event.key === 'D') {
                    const debugPanel = document.getElementById('timingDebug');
                    if (debugPanel) {
                        const isVisible = debugPanel.style.display !== 'none';
                        debugPanel.style.display = isVisible ? 'none' : 'block';
                        
                        if (!isVisible) {
                            app.debugger?.bindOverlay({
                                panel: debugPanel,
                                infoElement: document.getElementById('timingInfo'),
                                eventsElement: document.getElementById('debugEvents')
                            });
                            app.debugger?.toggle(true);
                        } else {
                            app.debugger?.toggle(false);
                        }
                    }
                }
            });
        }

        // Show error screen
        function showError(message) {
            const errorScreen = document.getElementById('errorScreen');
            const errorMessage = document.getElementById('errorMessage');
            
            if (errorMessage) {
                errorMessage.textContent = message;
            }
            
            if (errorScreen) {
                errorScreen.style.display = 'flex';
            }
            
            // Hide input shield
            const inputShield = document.getElementById('inputShield');
            if (inputShield) {
                inputShield.style.display = 'none';
            }
        }

        // Initialize the game
        async function initGame() {
            try {
                app.debugger?.log('init:start');
                updateProgress(0, 'Validating session...');

                const urlParams = new URLSearchParams(window.location.search);
                const bootstrap = urlParams.get('bootstrap');
                const storedNonce = sessionStorage.getItem('bootstrap_nonce');

                if (!bootstrap || bootstrap !== storedNonce) {
                    throw new Error('Invalid session. Please start over.');
                }
                sessionStorage.removeItem('bootstrap_nonce');

                updateProgress(1, 'Connecting to Spotify...');

                app.client = new SpotifyClient();
                await app.client.initialize();
                app.debugger?.log('init:clientReady');

                updateProgress(2, 'Checking Premium and finding devices...');
                await checkPremiumStatus();
                app.debugger?.log('init:devicesChecked');

                updateProgress(3, 'Connecting to native Spotify app...');

                app.playback = new NativeSpotifyPlayback(app.client);
                try {
                    const deviceInfo = await app.playback.initialize();
                    app.debugger?.log('init:playbackReady', {
                        deviceId: deviceInfo?.id,
                        deviceName: deviceInfo?.name
                    });
                    if (deviceInfo?.name) {
                        app.debugger?.setExtraMetrics({ 'Active Device': deviceInfo.name });
                    }
                } catch (error) {
                    if (error.message && error.message.includes('device')) {
                        throw new Error('Unable to connect to Spotify. Please make sure Spotify is open and playing on your device, then refresh this page.');
                    }
                    throw error;
                }

                updateProgress(4, 'Initializing game components...');

                app.timingClock = new TimingClock();
                app.debugger?.log('init:timingClockReady');

                const canvas = document.getElementById('gameCanvas');
                await Promise.all([
                    new Promise(resolve => {
                        app.engine = new GameEngine();
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.input = new GameInput(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.render = new GameRender(canvas);
                        resolve();
                    }),
                    new Promise(resolve => {
                        app.ui = new GameUI();
                        resolve();
                    })
                ]);
                app.debugger?.log('init:componentsReady');

                app.debugger?.attach({
                    engine: app.engine,
                    playback: app.playback,
                    timingClock: app.timingClock
                });

                bindPlaybackToEngine();

                console.log('Waiting for MIDI files to load...');
                await new Promise(resolve => {
                    const checkMidi = () => {
                        const availableTracks = app.engine.midiGenerator.getAvailableTracks();
                        if (availableTracks.length > 0) {
                            console.log(`MIDI loaded for ${availableTracks.length} tracks:`, availableTracks);
                            resolve();
                        } else {
                            console.log('Still waiting for MIDI files...');
                            setTimeout(checkMidi, 500);
                        }
                    };
                    checkMidi();
                });
                app.debugger?.log('init:midiReady');

                if (window.config && window.config.CHART) {
                    window.config.CHART.DENSITY_MULTIPLIERS = {
                        EASY: 1.0,
                        NORMAL: 1.5,
                        HARD: 2.0
                    };
                    window.config.CHART.MIN_NOTE_SPACING = 100;
                    console.log('Note density increased for more challenging gameplay');
                }

                updateProgress(5, 'Setting up event handlers...');
                setupEventHandlers();
                app.debugger?.log('init:handlersReady');

                updateProgress(6, 'Preparing game session...');
                await startGameSession();
                app.debugger?.log('init:sessionReady');

                updateProgress(7, 'Ready!');

                await autoCalibrate();
                setupDebugMode();
                app.debugger?.log('init:debugReady');

                await new Promise(resolve => setTimeout(resolve, 500));

                document.getElementById('inputShield').style.display = 'none';
                app.isInitialized = true;
                startGameLoop();
                app.debugger?.log('init:complete');
                app.debugger?.setExtraMetrics({ 'Initialization': 'Complete' });

            } catch (error) {
                console.error('Game initialization failed:', error);
                
                let errorMessage = error.message;
                
                if (error.message.includes('device') || error.message.includes('Spotify')) {
                    errorMessage = `
Unable to connect to Spotify. Please make sure:

1. Spotify is open on your device
2. You're playing music (any song is fine)  
3. You have a stable internet connection
4. You have Spotify Premium

Then refresh this page and try again.
                    `.trim();
                }
                
                showError(errorMessage);
                app.debugger?.log('init:error', { message: error.message });
                app.debugger?.setExtraMetrics({ 'Initialization': 'Failed' });
            }
        }

        // Initialize page and start detection immediately
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startSpotifyAutoDetection);
        } else {
            // DOM is already ready
            startSpotifyAutoDetection();
        }
    </script>
</body>
</html>
